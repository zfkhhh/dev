mysql有三种日志：
1. undo log 回滚日志，用于回滚事务
2. redo log 重做日志，用于服务宕机恢复数据
3. binlog，用于主从复制、数据恢复

一、buffer pool
1. 为了减少磁盘io，innodb设计了缓冲池buffer pool
2. 读数据时，如果buffer pool存在数据，直接读buffer中的数据，不存在从磁盘中读出数据并写入buffer；写数据，如果buffer中存在，修改数据并将数据页设置为脏页，不存在就先读数据到buffer再写，后续由后台线程刷盘
3. 在mysql启动时，会申请一片连续内存空间，按16k大小划分页，为缓存页，其他包含索引页、数据页、undo页等


二、undo log
1. 实际上mysql数据修改，会隐式的开启事务，默认开启的autocommit配置会自动提交
2. 在事务提交过程中，服务宕机如何回滚更新？实现机制就是undo log，保证了事务的原子性
3. 在事务开启的时候，undo log会记录旧数据，每当innodb进行数据修改时，会把必要的数据记录到undolog，如插入时记录主键等，回滚时读undolog进行相反操作
4. undolog还有一个作用：和read view实现mvcc；行数据结构会有旧版本undolog指针和事务id，快照读会根据指针找到当前事务可见的版本的行数据
5. undolog和数据页一样，会缓存到buffer pool中，buffer pool中有undo页，会持久化到redolog中，redolog会根据刷盘机制进行持久化


三、redo log
1. buffer pool在内存，如果宕机内存数据丢失，需要将buffer pool中的脏页、undolog刷新到磁盘；过程就是更新时先更新内存设置为脏页，再以redolog格式记录，后续innodb会按照一定时机在后台线程将脏页写入磁盘；这也就是wal技术，修改数据先将日志持久化，再持久化数据
2. redolog是物理日志，记录了对数据页的修改，只要redolog持久化到磁盘了，服务宕机可以通过redolog恢复数据
3. redolog和undolog的区别
3.1 redolog记录的是事务完成后的数据状态，undolog记录的是事务完成前的状态
3.2 事务提交前宕机，通过undolog回滚到事务开始的状态；事务提交后宕机，通过redolog恢复到事务提交后的状态
3.3 undolog是通过redolog格式记录到磁盘的（记录对undo数据页的修改）
4. 为什么需要redolog
4.1 redolog是追加顺序写，而写数据是随机写（需要找到磁盘的数据页）,顺序写比随机写效率高
4.2 redolog提供了事务的持久性，奔溃恢复的能力
5. redolog是直接写入磁盘？
5.1 redolog实际也是先写入缓存redologbuffer,达到某一时机再写入磁盘
5.2 写入磁盘的时机
5.2.1 mysql正常关闭
5.2.2 redologbuffer的写入量达到buffer空间的一半
5.2.3 每隔1s innodb的后台线程将redolog写入磁盘
5.2.4 事务提交的配置,提供了三种值；对于0和2的选择，0比2效率高，但安全性不如
5.2.4.1 值为0，事务提交不触发写入磁盘
5.2.4.2 值为1，事务提交时直接将redolog持久化到磁盘
5.2.4.3 值为2，事务提交后将redolog写入到操作系统的page cache，交由操作系统决定写入磁盘
5.3 redolog写满：默认情况innodb会设置两个redolog文件（叫重做日志组），通过写指针和check指针做成环形，写指针记录写的位置，check指针记录擦除的位置；当两个文件写满也就是指针相交，mysql会阻塞

四、binlog
1. undolog和redolog都是innodb引擎层，binlog是在server层，不管什么引擎，在完成一次更新都会记录一条binlog，在事务提交后将所有binlog写入文件
2. redolog和binlog的区别
2.1 redolog是innodb的实现，binlog是server层的实现，不管什么引擎都会执行
2.2 文件格式不同，redolog记录了修改了什么数据页，binlog包含三种格式，statement是记录更新操作的sql（逻辑日志），row是记录数据行最终被修改的状态（但是每行数据都会记录会造成binlog过大），mixed是混合了前两种
2.3 写入方式不同，redolog是循环写，即日志大小是固定的，会覆盖旧日志；binlog是追加写，写满一个文件会新增文件，这也就是可以通过binlog恢复数据库以及主从复制
3. 主从复制的过程：
3.1 事务提交后，会先写入binlog，再提交事务
3.2 从库会开启一个io线程连接主库的log dump线程，接收binlog写入中继日志
3.3 从库读取binlog日志，回放日志中记录的sql
4. 主从复制的模式
4.1 同步复制：提交事务的线程需要完成复制到从库，才响应成功
4.2 异步复制：事务提交不会等binlog同步完成
4.3 半同步复制：事务提交有部分从库复制完成就响应成功
5. binlog写入磁盘的流程
5.1 binlog也有binlog cache，事务执行过程中，把每个binlog记录写入cache，当事务提交时将binlog从缓存写入文件（无论事务的binlog有多少，都得一次写入）
5.2 mysql为每个线程分配了binlog cache，会先写入到page cache，再fsync到磁盘，其中fsync到磁盘是io操作，存在配置sync_binlog
5.2.1 sync_binlog为0，每次提交事务不fsync，交由操作系统自己判断什么时候写入磁盘
5.2.2 sync_binlog为1，每次提交事务马上执行fsync
5.2.3 sync_binlog为N，即累积n个事务后执行fsync

为了提高性能，一般设置sync_binlog在100-1000

五、二阶段提交
1. 按照redolog和binlog的刷盘配置，事务提交后，redolog和binlog都要从cache写入到文件，如果两个写入有一个失败，如redolog失败，主库奔溃恢复为旧数据，从库为新数据；如binlog失败，主库为新数据，从库为旧数据，需要保证redolog和binlog刷盘的原子性
2. 二阶段提交就是开启内部xa事务，将刷盘分为两个阶段，第一阶段准备阶段，将redolog写入磁盘并记录事务id，并设置为prepare状态；第二阶段提交阶段，将事务id写入binlog，binlog写入磁盘，成功后再将redolog状态设置为commit
* 按照配置如果是写入到page cache，也是一样的，写入到page cache就算写入成功
3. 二阶段提交可以处理各个阶段的宕机，mysql重启先读redolog，如果在准备阶段失败就不会有redolog，获得事务id，根据事务id查binlog，如果查询不到说明写入binlog失败，回滚事务即可，如果查到了binlog但是redolog不是commit状态，提交事务即可
4. 二阶段提交存在问题：
4.1 磁盘io次数多，刷盘时会有redolog刷盘和binlog刷盘
4.2 锁竞争激烈，内部xa事务获得锁才会进入准备阶段，提交阶段完成才会释放锁
4.2.1 所以有redolog组提交和binlog组提交，将多个刷盘操作合并成一次io

六、完整的update流程
1. innodb的执行器会根据update的where条件，调用索引树（如果是主键就是聚簇索引，非主键就是非聚簇索引）找到行记录
1.1 如果记录所在数据页在buffer pool,返回记录给执行器
1.2 如果不在buffer pool,先从磁盘读到buffer pool，返回记录给执行器
2. 执行器判断原记录和更新后记录是否存在区别，不存在就不会进行后续操作
3. 开启事务，先记录undolog，会修改buffer pool中的undo页，修改undo页会记录redolog
4. 事务执行，先更新buffer pool中对应数据页，设置为脏页，将数据页修改记录写入到redolog，每个修改已binlog记录写到binlog cache。后台线程会根据时机将数据修改写入磁盘
5. sql语句执行完成，server层写入binlog，先写入binlog cache，待事务提交时写入磁盘（按照配置看是写入page cache还是磁盘）
6. 事务提交，二阶段提交：准备状态：写入redolog并设置为prepare状态，提交阶段，先写入binlog，再更新redolog为commit状态
7. 完成更新

七、磁盘io问题
mysql更新操作需要写入redolog、binlog以及数据更新，都需要io操作，会造成磁盘io很高，优化配置
1. 设置组提交，合并多次binlog和redolog为一次io
2. binlog的sync配置，设置为大于1，即多个事务提交到page cache后再进行fsync写入磁盘
3. redolog的sync配置，设置成先写入page cache，等待redolog的刷盘时机时再写入磁盘