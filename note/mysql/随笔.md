1. 如果分析慢查询的情况；可以分为偶然的慢查询和一直都很慢
1.1 偶然的慢查询
1.1.1 数据库在刷脏页，buffer pool中的脏页会写入到redolog中，而redolog是环形写入
1.1.1.1 当redolog写满，会阻塞写入，数据库不再接收更新；只有数据库更新操作过多，脏页来不及刷到磁盘然后擦除redolog的数据页更新，导致redolog满了
1.1.1.2 buffer pool满了，新的数据页加入需要淘汰最久不使用的页，如果是脏页就需要刷盘
1.1.2 竞争锁：快照读基于mvcc是不会被锁阻塞，但是当前读需要加行锁间隙锁，如果数据范围已经被锁住会阻塞
1.1.3 数据库内存或者网络资源不够，当前数据库压力大，查询数据阻塞
1.2 sql一直很慢
1.2.1 查询的语句没有覆盖到索引
1.2.2 语句有索引但是索引失效了，需要分析查询语句
1.2.2.1 使用联合索引但是查询条件没有满足最左匹配
1.2.2.2 使用联合索引但是范围查询，导致联合索引只有部分索引生效
1.2.2.3 条件列使用了计算、函数
1.2.2.4 or的右边条件没有覆盖到索引，导致前面的条件索引失效
1.2.2.5 like左模糊、左右模糊
1.2.2.6 隐式的类型转换，比如查询列为字符串但是传了整形
1.2.2.7 查询优化器选择索引问题，比如当查询条件查出的数据占了10～30%，优化器会选择全表扫描
1.2.2.8 delete in，in条件里面时子查询，走的是全表扫描；实际上selet in是优化成了join所以可以走索引；解决方法一个是改成join，还有就是表定义别名（别名会走join逻辑）
1.2.3 表数据条数已经到了一定量级（千万级以上），查询速度会变慢；这个具体量级和主键长度、每行大小相关，当数据量达到一定量级，会导致b+数四层，索引页无法缓存等
1.2.4 sql语句有问题，需要优化
1.2.4.1 过多的join或子查询，一方面需要考虑子查询的索引问题，一方面如果创建的临时表过大导致不是在缓存而是在磁盘创建，那么磁盘io会造成效率差
1.2.4.2 order by文件排序
1.2.4.2.1 当行数据长度超过sort_data配置时，会以rowid进行排序，还需要回表然后在sort_buffer中排序
1.2.4.2.2 当排序内容过大，sort_buffer不够，会在文件排序，效率差
1.2.4.3 group by分组，group by会产生临时表，当临时表过大会在磁盘上创建，磁盘上会文件排序


2. mysql对于区分度不高的字段（如状态status只有1，2）是否需要加索引？
2.1 不需要建索引，参考文章 https://blog.csdn.net/sywangnaiqing/article/details/116064924
2.1.1 如果只通过status查询status数据如count，两个状态数据不管是差距大还是差距相当，查询多的部分、少的部分、相当的部分都会走索引ref,都会提升效率
2.1.2 如果通过status和其他非索引字段查询
2.1.2.1 当status查询的较少部分，效率提升
2.1.2.2 当status查询相当或者较多部分，索引反倒会照成效率降低
2.2 为什么加索引反倒会造成效率降低？
2.2.1 status是非聚簇索引，在b+树结构叶子结点存放的id主键，当where查询status和其他条件需要通过回表查询较多行数据，这就会造成灾难
2.2.2 假如一张表有三百万数据，每行数据50byte,一个数据页是16kb去除表头15kb存行数据，即一个数据页有300行，总共一万页，全表扫描也就顺序扫描这一万页数据；status查询的是20%数据，也就是60万行，因为通过索引的查询，每次通过主键id的查询数据都需要寻址到数据页，在buffer中逻辑读到对应的行，也就是60万次的寻址读数据页
2.2.3 主要差距就在于找数据页的时间

3. mysql in慢查询原因
3.1 in中如果是子查询会造成外部查询不会走索引，走全表扫描；in(1,2,3)没这个问题
3.2 mysql在碰到in子查询时，优化器会将in语句转化成exists子查询;类似于
`
select * from employee where employee_id in (select employee_id from account where  account.is_active = 1);
=>
select * from employee where EXISTS (select 1 from account,employee where account.employee_id = employee.employee_id and account.is_active = 1);
`
因为存在函数，这就造成索引无效
3.3 优化成join或者表定义别名，可以走索引

4. mysql不同索引更新记录会死锁吗
4.1 并发情况会出现死锁，https://blog.csdn.net/lixia0417mul2/article/details/128773971
4.2 如果存在多个二级索引关联同一个字段，当某个索引更新数据，需要给索引树加锁，然后需要更新其他索引树保证数据一致性，如下
`
create table user(
id bigint(20) not null primary key comment '主键',
cn_name varchar(100) not null comment '中文名称',
en_name varchar(100) not null comment '英文名称'，
is_deleted int not null comment '是否删除'，
index cn_del_index('cn_name','is_deleted'),
index en_del_name('en_name','is_deleted')
)engine = innodb;
insert into user value(1, 'lixia', 'jame', 0); 
...模拟插入很多条记录

update user set is_deleted=1 where cn_name='lixia'
update user set is_deleted=1 where en_name='jame'
`
sql1中需要将cn_del_index索引树加锁，然后更新is_deleted，为了数据一致性需要将索引树en_del_name更新，需要加en_del_name的锁；同理sql2需要先加en_del_name索引树的锁，再给cn_del_index索引树加锁，可能出现互相等待的情况

5. 深翻页问题？如何解决
5.1 深翻页问题指表存在大量数据，通过非聚簇索引查询数据，并且翻页offset较大，导致分页查询数据过慢
5.2 本质上是非聚簇索引回表的问题，mysql会扫描offset+limit行，然后丢弃offset行，需要回表offset+limit行数据
5.3 优化方案：
5.3.1 如果查询数据所需字段都在索引上，可以索引覆盖，不需要回表
5.3.2 通过子查询方式，子查询先查出满足条件的二级索引的主键id，主语句根据id往后查询limit条数据
5.3.3 通过inner join延迟关联，先把分页的主键id查出来再到表通过inner join内联查到完整数据

6. mysql自增主键一定是连续的吗？
6.1 在mysql中，8.0之前将自增主键存在内存中，每次重启都会找主键max(id)，+1作为自增值；在8.0后，将自增值的变更记录存在了redolog中
6.2 在插入数据，如果主键值为0，null或者没有设置，使用自增主键
6.3 自增主键非连续的场景
6.3.1 事务回滚造成的主键不连续：在8.0中，如果事务或者插入数据中主键通过自增生成，如果事务回滚或者插入失败，自增值已增加不会随着事务回滚，造成主键不连续；但如果是5.7，在失败后mysql重启，主键自增值又连续了
6.3.2 插入数据设置了主键值，会造成不连续
6.3.3 mysql中存在设置自增初始值和自增步长，自增初始值和自增步长设置不为1自然就是不连续的
6.3.4 批量插入insert...select语句，批量插入时申请id，mysql并不知道要多少id,所以申请时每次申请到的自增id个数都是上一次的两倍，如从其他表查到5条数据，会申请3次id，第一次1条，第二次2条，第三次4条，那么就造成了两个自增id未使用