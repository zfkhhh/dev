1. 如果分析慢查询的情况；可以分为偶然的慢查询和一直都很慢
1.1 偶然的慢查询
1.1.1 数据库在刷脏页，buffer pool中的脏页会写入到redolog中，而redolog是环形写入
1.1.1.1 当redolog写满，会阻塞写入，数据库不再接收更新；只有数据库更新操作过多，脏页来不及刷到磁盘然后擦除redolog的数据页更新，导致redolog满了
1.1.1.2 buffer pool满了，新的数据页加入需要淘汰最久不使用的页，如果是脏页就需要刷盘
1.1.2 竞争锁：快照读基于mvcc是不会被锁阻塞，但是当前读需要加行锁间隙锁，如果数据范围已经被锁住会阻塞
1.1.3 数据库内存或者网络资源不够，当前数据库压力大，查询数据阻塞
1.2 sql一直很慢
1.2.1 查询的语句没有覆盖到索引
1.2.2 语句有索引但是索引失效了，需要分析查询语句
1.2.2.1 使用联合索引但是查询条件没有满足最左匹配
1.2.2.2 使用联合索引但是范围查询，导致联合索引只有部分索引生效
1.2.2.3 条件列使用了计算、函数
1.2.2.4 or的右边条件没有覆盖到索引，导致前面的条件索引失效
1.2.2.5 like左模糊、左右模糊
1.2.2.6 隐式的类型转换，比如查询列为字符串但是传了整形
1.2.2.7 查询优化器选择索引问题，比如当查询条件查出的数据占了10～30%，优化器会选择全表扫描
1.2.2.8 delete in，in条件里面时子查询，走的是全表扫描；实际上selet in是优化成了join所以可以走索引；解决方法一个是改成join，还有就是表定义别名（别名会走join逻辑）
1.2.3 表数据条数已经到了一定量级（千万级以上），查询速度会变慢；这个具体量级和主键长度、每行大小相关，当数据量达到一定量级，会导致b+数四层，索引页无法缓存等
1.2.4 sql语句有问题，需要优化
1.2.4.1 过多的join或子查询，一方面需要考虑子查询的索引问题，一方面如果创建的临时表过大导致不是在缓存而是在磁盘创建，那么磁盘io会造成效率差
1.2.4.2 order by文件排序
1.2.4.2.1 当行数据长度超过sort_data配置时，会以rowid进行排序，还需要回表然后在sort_buffer中排序
1.2.4.2.2 当排序内容过大，sort_buffer不够，会在文件排序，效率差
1.2.4.3 group by分组，group by会产生临时表，当临时表过大会在磁盘上创建，磁盘上会文件排序


2. mysql对于区分度不高的字段（如状态status只有1，2）是否需要加索引？
2.1 不需要建索引，参考文章 https://blog.csdn.net/sywangnaiqing/article/details/116064924
2.1.1 如果只通过status查询status数据如count，两个状态数据不管是差距大还是差距相当，查询多的部分、少的部分、相当的部分都会走索引ref,都会提升效率
2.1.2 如果通过status和其他非索引字段查询
2.1.2.1 当status查询的较少部分，效率提升
2.1.2.2 当status查询相当或者较多部分，索引反倒会照成效率降低
2.2 为什么加索引反倒会造成效率降低？
2.2.1 status是非聚簇索引，在b+树结构叶子结点存放的id主键，当where查询status和其他条件需要通过回表查询较多行数据，这就会造成灾难
2.2.2 假如一张表有三百万数据，每行数据50byte,一个数据页是16kb去除表头15kb存行数据，即一个数据页有300行，总共一万页，全表扫描也就顺序扫描这一万页数据；status查询的是20%数据，也就是60万行，因为通过索引的查询，每次通过主键id的查询数据都需要寻址到数据页，在buffer中逻辑读到对应的行，也就是60万次的寻址读数据页
2.2.3 主要差距就在于找数据页的时间