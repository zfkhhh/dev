一、锁
1. mysql的锁分为：全局锁、表级锁、行级锁
2. 全局锁：flush tables with read lock全局读锁
3. 表级锁：共享/独占表锁，元数据锁，意向共享/独占锁，自增锁
4. 行级锁：行锁record lock，间隙锁gap lock,临键锁next-key lock,插入意向锁
5. 按作用可以分为：共享锁（s)，独占锁（x）

二、全局锁
1. 全局读锁：flush tables with read lock，解锁：unlock tables
2. 全局读锁用于全库逻辑备份，让备份数据库期间，不会因为表结构变动或者数据更新，出现备份数据库数据不一致

二、表级锁
1. 共享/独占表锁：读锁 lock tables t_student read; 写锁 lock tables t_student write；解锁 unlock tables
1.1 当线程占有锁，不仅限制其他线程的读写，还会限制当前线程的读写；如限制占了读锁，当前线程同样不允许写
2. 元数据锁mdl：表结构的锁，同样有mdl读锁和mdl写锁
2.1 mdl锁在事务提及后释放，事务中会一直持有
2.2 会造成问题当事务占有mdl读锁时有事务修改表结构，申请mdl写锁，这之后的所有select语句都会阻塞，因为写锁优先级高于读锁，写锁等待时后阻塞后续所有的读操作
3. 意向锁：innodb在给表记录加共享/独占锁时，会先给表加上意向共享/独占锁，这里的查询得是当前读（select...for update），快照读基于mvcc不会加锁
3.1 意向锁的作用是快速判断表内记录是否加锁；当需要给表加共享/独占表锁时，如果没意向锁，需要遍历表的所有记录判断是否存在锁
4. 自增锁auto-inc；表存在自增主键，当插入数据未设置主键值时，需要auto-inc锁，插入成功后就会释放auto-inc锁（所以事务回滚主键值会不连续）
4.1 因为是表级锁在大量数据插入时会影响性能，mysql5 innodb引擎提供了轻量级锁，在插入数据时，加锁给主键赋了一个自增值后就解锁；innodb引擎提供了一个参数innodb_autoinc_lock_mode，有三个枚举：0 使用auto-inc锁 2 使用 轻量级锁 1 普通insert使用轻量级锁，批量插入使用auto-inc锁
4.2 轻量级锁数据不一致问题：当binlog是statement格式，两个事务对表进行插入，一个insert插入，一个批量插入insert into select，当批量插入时需要分两次申请轻量级锁获得主键自增值，在两次之间另一个事务申请了主键自增，就会导致insert获得了主键id=3,批量插入获得id=1,2,4,5；从库顺序执行命令主键会不一致
4.3 如果是自增锁auto-inc就不会有问题，因为必须插入语句提交才会释放主键的锁，批量插入的两次申请是原子的
4.4 当lock_mode=2使用轻量级锁时需要将binlog模式改为row记录数据行的最终状态

三、行级锁
1. innodb引擎支持行级锁，myisam不支持行级锁；
2. 行锁是锁定一行数据，分为s锁，x锁；像当前读select for update就会加x锁，其他事务在占有锁之前无法修改行数据
3. 间隙锁gap lock：只在可重复读隔离级别，是锁住两条记录间的间隙；间隙锁是兼容的，可以多个事务持有一个间隙锁
4. 临键锁next-key lock:行锁+间隙锁，(3,5]，锁住了(3,5)间隙和行记录5；next-key lock不同事务获得x锁，或者xs锁会互斥
5. 插入意向锁：事务插入一条记录时，需要判断是否存在间隙锁，如果存在会阻塞插入，并创建插入意向锁表示有事务想在某个区间插入数据，正在处于等待状态，它是一种间隙锁