一、事务四大性质
1. 原子性：要么成功要么失败
2. 一致性：事务前后数据库数据保持一致性状态
3. 隔离性：事务间相互隔离
4. 持久性：事务操作持久化

二、四大隔离级别

1. 读未提交：事务可以读到其他事务中未提交的数据，存在问题：脏读、不可重复读、幻读
脏读：读到了另一个事务中修改的数据，如果另一个事务回滚，当前事务读的数据就是过期的数据

2. 读已提交：事务变更提交后，他的变更其他事务才能看到，存在问题：幻读、不可重复读
不可重复读：事务a先读数据，事务b修改数据提交，事务a再次读数据发现数据不一致

3. 可重复读：事务中看到的数据和开始读到的数据一致
幻读：事务a读到区间的数据数目，事务b往区间数据插入了新数据，事务a再读数据数目不同

幻读和不可重复读：幻读针对insert和delete，不可重复读是update；幻读针对一批数据，不可重复读查询的是一个数据项

4. 串行：不存在并发

三、mysql解决幻读的大部分场景

innodb默认事务类型是可重复读，存在幻读问题，通过mvcc和间隙锁解决了大部分幻读的场景

1. 快照读（普通select），mvcc版本控制，在事务内只能查询到小于等于事务开始时的版本以及事务内操作导致的版本增加数据；对与其他事务插入的数据查询不到
2. 当前读（select for update)，通过间隙锁解决，当select for update时，会给记录范围加上间隙锁，当要插入、删除这个范围内数据会被阻塞

还存在场景会幻读：
1. 事务a先查询不存在的数据，事务b插入了该条数据，事务a执行update后再查询，会发现查询成功
2. 事务a先快照读，事务b修改，事务a再当前读，会发现读到了事务b修改后的数据（要避免这个问题要么在事务开始时当前读，要么就不要当前读）


四、mvcc机制

1. innodb的行数据结构包含两个字段：事务修改操作时事务id、指向旧版本的指针
2. mvcc的read view中结构为：创建事务id，创建readview时活跃的事务id列表，活跃的事务中最小事务id min_id，创建readview时应该给下一个事务的id max_id
3. 对于快照读，查询数据时可以分为三种情况
3.1. 行记录中事务id小于min_id的，表示是已提交的数据，可见
3.2. 行记录事务id大于max_id的，表示是未提交的数据，不可见
3.3. 行记录在min_id和max_id之间，如果是在readview记录的活跃事务id列表中，表示事务未提交数据，不可见；如果不在，表示是在当前事务过程中提交的数据，可见

