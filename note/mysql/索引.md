一、索引的分类
1. 数据结构：b+树索引、hash索引、full-text索引
2. 物理存储：聚簇索引、非聚簇索引
3. 特性：前缀索引、唯一索引、普通索引、主键索引
4. 字段数量：联合索引、单列索引

二、b+树索引

b+树结构
1. b+树的非叶子节点只存放索引范围，叶子节点如果是聚簇索引存放真实数据行，非聚簇存放主键列，叶子节点是双向链表方便范围查询
2. b+树是平衡树，节点存放的是一个范围的多个数据项，当插入数据达到个数限制会分裂成两个节点并平均数据数量；删除节点也会导致兄弟节点的合并
b+树相比b树的优点：
1. b+树单一节点能存放更多元素，查询的io更少
2. 所有的查询都要查到叶子节点，查询性能更稳定
3. b+树叶子节点有双向指针，便于范围查询

* 超过千万数据性能急剧下降的原因
1. mysql查询以数据页为最小单位，大小16k，其中包含了一些header信息，剩下15k左右存放行数据
2. b+树结构，非叶子节点存放主键索引和页号，叶子节点存放行数据；页号为4byte，假设主键8byte，所有非叶子节点能存放的主键数量是15k/12=1280;假设行大小1k，叶子节点能存放15行数据；总数据行=1280*1280*15（三层b+树），约等于两千万
3. 超过两千万数据就会照成b+树加深，需要io次数增加；且因为mysql会将表索引加载到内存中，如果表索引过大内存无法存储索引，那查询数据就需要多次磁盘io；很明显，能存放的数据受主键大小、行数据大小影响，可以存放的数据是千万级浮动
4. 随着固态硬盘、内存的发展，即使深度增加，io也不会是限制数据量的根本因素
5. 结构调整的并发问题：b+树结构调整过程中，其他线程读取数据会有锁的并发控制：先用乐观锁尝试修改（如追加节点），如果修改会影响结构，会对根节点加悲观锁，所以并发写会阻塞，当有大量结构调整，b+树就会出现很严重的性能瓶颈；既限制数据量


三、聚簇与非聚簇
聚簇索引：当主键为索引，叶子节点存放的行数据，这里的主键包括
1. 当存在主键的时候，主键作为索引键
2. 不存在主键，找第一个not null的唯一键
3. 都不存在，会在行结构的额外数据中，设置一个自增id作为隐藏主键

非聚簇索引：叶子节点存放的是主键值

所以，通过非聚簇索引查数据，需要一次回表，既先通过非聚簇索引查到主键id，再通过聚簇索引查到行数据
有两种情况不一定会回表：
1. 索引覆盖，当非聚簇索引的叶子节点包含了要查询的所有列，就不需要回表查行数据
2. 索引下推：在mysql5.6之后，存在索引下推
mysql结构包括存储引擎层和服务层，下推意思是将部分服务层工作下移到存储引擎层执行
例如当where多条件查询，第一个条件不会直接返回服务层，而是比对后面的条件，找到符合条件的主键再回表；可以减少回表的次数

四、联合索引

联合索引就是多列作为索引值，存在最左匹配原则：
1. 联合索引优先匹配最左边的列，按索引列顺序排序，后续的列是全局无序，局部有序的；不满足最左匹配索引会失效，如索引(a,b,c)，只能匹配a,ab,abc的查询条件
2. 联合索引的范围查询：虽然满足最左匹配，但一些场景会造成联合索引只匹配部分
2.1 大于、小于条件：只会第一个字段匹配索引，其他条件匹配不了；因为大于小于条件下查询的索引范围，对于后面的条件是无序的
2.2 大于等于、小于等于：在第一个条件等于的范围内，第二个条件是有序的（以a=1,b=1开始范围查找），匹配联合索引
2.3 between：在mysql里面是>=和<=,类似与2.2，可以匹配联合索引
2.4 右模糊查询：其实也是在以%前的字符相等开始，右模糊a%,类似于[a,)条件，类似2.1可以匹配联合索引
3. 联合索引排序：如果存在以某个字段排序，可以将排序字段作为联合索引，既通过前面条件查询的数据范围内是有序的；可以避免mysql的文件排序
3.1 SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] = [value] ORDER BY [sort];建立一个联合索引(columnX,sort)来实现order by 优化
3.1.1 如果字段批量查询无法用联合索引优化；因为联合索引是全局无序的，in查出的数据sort字段是无序的 SELECT [column1],[column2],…. FROM [TABLE] WHERE [columnX] IN ([value1],[value2],…) ORDER BY[sort]
3.2 多字段order by用(uid,x,y)比建立(x,y,uid)索引效果要好；SELECT * FROM [table] WHERE uid=1 ORDER x,y

五、索引优化
1. 前缀索引优化：如果索引列为大字符串，且存在较大前缀差异，可以配置前缀索引，索引树只存部分前缀；但是order by和索引覆盖无法使用
2. 覆盖索引优化：非聚簇索引尽量包含常用的查询数据，查询语句尽量是需要用到的字段
3. 自增主键：使用自增主键，b+树结构就插入数据就是追加数据；如果是非自增，会随机到某个数据页的某个位置，可能会造成数据移动，甚至页分裂（指的是页空间不足，需要创建新的页移动保存数据），造成内存碎片
4. 列设置成not null:
4.1 数据行结构的额外数据里，会存放可以为null的列，如果存在，会至少占一字节的空间
4.2 null会造成优化器索引选择、索引统计、值比较时更复杂
5. 避免索引失效
5.1 联合索引不满足最左匹配
5.2 联合索引范围查询造成的联合索引部分失效
5.3 索引扫描的数据达到总数据的10%-30%，会执行全表扫描，索引失效（列设置成null的话，过多null字段会造成索引失效）
5.4 左模糊、左右模糊匹配会造成索引失效
5.5 查询时使用计算、函数操作会索引失效，因为索引保存的字段原始值（mysql8加入了函数索引，可以针对函数计算加索引，例如加上length计算的索引）
5.6 or条件，如果右边非索引列，会造成左边索引失效
5.7 索引字段隐式类型转换，例如字段本身是字符串查询时传整形，会隐式的将字段的字符串通过CAST函数转成整数和入参比较，即类似于使用了函数操作，索引失效；但是字段类型是整数传了字符串会走索引；因为mysql的数据类型转换规则，自动将入参中字符串转成整数
5.8 delete in，in条件里面时子查询，走的是全表扫描；实际上selet in是优化成了join所以可以走索引；解决方法一个是改成join，还有就是表定义别名（别名会走join逻辑）

六、索引缺点
缺点：
1. 数据量较大时，索引需要占用较大的空间
2. 创建、维护索引需要消耗性能；数据插入、删除，需要维护索引，会影响性能
 
 七、主键和唯一索引的区别
 1. 主键索引是唯一索引，唯一索引不一定是主键索引，主键索引只能有一个，唯一索引可以多个
 2. 主键索引不允许空值，唯一索引允许空值
 3. 主键是约束，用了确保表的数据完整性，可以通过primary key设置，设置主键会自动创建一个唯一索引；唯一索引确保数据的唯一性
 - 完整性指数据在整个生命周期任何阶段都是准确、完整、一致的
