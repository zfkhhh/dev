tcp是可靠的传输层通讯协议，通过序列号、确认应答、重传机制、滑动窗口、流量控制、拥塞控制等等机制保证可靠性

一、序列号与确认应答
1. tcp头有数据序列号和确认序列号，当两端发送数据时，会先获得对方的序列号，序列号表示当前数据包的数据，确认序列号是期望的数据
2. 三次挥手、消息传输都会通过这两个序列号完成顺序传输

二、重传机制
1. 对于数据包丢失，tcp提供了重传机制，常见的重传机制有四种：超时重传，快速重传，sack，d-sack
2. 超时重传：发送数据包时设置一个定时器，超过指定时间没有响应就重传数据包；对于tcp连接，会有两种超时，数据包丢失、确认应答包丢失
2.1 rtt，数据包往返时间，rto超时重传的超时时间，我们需要尽量将rto设置成略大与rtt，但是rtt实际上是动态的，随着网络状况变化，那么rto也需要是动态变化的
2.2 rto需要采样rtt计算出一个加权平均，需要计算rtt波动范围；在linux下tcp策略是超时间隔加倍，当遇到一次超时就设置超时时间为两倍
2.3 超时重传的超时周期会比较长，快速重传解决超时等待的问题
3. 快速重传：以数据驱动重传，当收到3个相同的ack时，在定时器过期之前重传丢失的ack包
3.1 快速重传解决了等待超时时间的问题，但是没有解决重传哪些数据包的问题，当多个数据包只丢失了中间两个包ack2，3，接收方之后接收的多个包都返回重传ack2，如果只传一个ack2，那之后又会返回重传ack3，如果传ack2后的所有包，会浪费资源，所以需要能确认哪些包丢失
4. sack：选择性确认，在tcp头部加一个sack字段，返回接收方已收到的数据包序号，发送方就能确认哪些包需要重传
4.1 linux的tcp_sack选项可以打开，linux2.4之后默认打开
5. d-sack：使用d-sack来告诉发送方哪些包被重复接收了，用于确认网络状况
5.1 ack包丢失：接收方的ack包丢失，达到超时重传，发送方会重传前面的数据包，接收方发送的sack会告诉发送方前面的包已经接收了，这个sack就是d-sack，是ack包丢失
5.2 网络延迟：发送方有个数据包丢失，达到快速重传，发送方快速重传了这个包，网络延迟的这个包到了接收方，接收方会发一个sack表示收到了重复消息，这个包就是d-sack
5.3 d-sack的作用可以知道是发送方发送的包丢失了，还是接收方的ack包丢失了，或者是网络延迟

三、滑动窗口
1. tcp每发送一个数据包都需要确认应答，这种方式如果往返时间长，效率比较低
2. tcp引入窗口概念，指定窗口大小，窗口大小就是无需等待确认，可以继续发送数据包的最大值；窗口是操作系统开辟的一个缓存空间，发送方在确认应答返回前，必须在缓存空间保存已发送的数据，当确认应答将数据删除
3. 因为窗口存在，当连续发送多个数据包，如果存在数据包ack丢失，可以通过下一个数据包ack信息确认是ack丢失还是数据丢失，这个模式是累计确认或累计应答
4. 发送方、接收方都有窗口，但窗口大小由接收方窗口大小决定，发送方发送的数据不能超过接收窗口大小，不然接收方处理不了
4.1 发送方的滑动窗口可以分为四部分：1已发送的数据且确认的数据，2已发送还未确认的数据，3未发送但总大小在接收方处理范围内，4未发送但总大小在接收方处理范围外的；通过三个指针来处理这四部分，snd.wnd表示发送窗口大小，也就是2+3，snd.und表示2的第一个字节，snd.nxt表示3的第一个字节；可用窗口大小就是wnd-(nxt-und)
4.2 接收方的滑动窗口可以分为三部分，1已接收并确认的数据，2可以接收的数据，3超出能接收数据的范围；rcv.wnd就是接收方滑动窗口大小，rcv.nxt就是2的第一个字节也就是能够接收数据的第一个字节的位置
4.3 发送方的滑动窗口大小约等于接收方的滑动窗口，滑动窗口是动态的，当接收方处理完数据会通过tcp头的windows字段告诉发送方

四、流量控制
1. 因为滑动窗口的存在，发送方能过知道接收方能接收数据的范围，接下来就是需要流量控制，来让发送方根据接收方的实际的接收能力来控制发送的数据量
2. 滑动窗口的实际数据是存在操作系统的缓冲区，当操作系统资源紧张时，会调整滑动窗口大小，会先收缩窗口大小，然后减小缓冲区大小
3. 服务端阻塞没有及时读接收方窗口数据，最后可用窗口为0，窗口关闭，服务端恢复会发送非0的ack报文给客户端，如果这个报文丢失会死锁，所以当tcp一方接收到零窗口通知，会设置持续计时器，当计时器超时，会发送窗口探测报文，窗口探测一般为3次，每次30～60秒，当超过三次有的tcp实现会发送rst报文中断连接
4. 糊涂窗口综合症，就是当接收窗口变小后，每次只有几字节的空间，发送方也会发送这几字节的数据，然而tcp头+ip头就有40字节了，性价比低；要解决这个问题分为两部分：1接收方不通知小窗口 2发送方小窗口不发送消息
4.1 接收方的策略通常是当窗口大小小与mss(tcp每次能传输的最大报文长度)或者缓冲区的一半，就不通知窗口大小
4.2 发送方使用nagle策略，两个条件：
4.2.1 接收方窗口大于等于mss并且可发送数据大小大于等于mss
4.2.2 接收方收到之前发送数据的ack回包
4.3 明显，光发送方开启nagle不够，需要发送方开启nagle+接收方设置不通知小窗口
4.4 nagle是默认打开的，像ssh，telnet会有小数据包交互的，可用通过tcp_nodelay来关闭

五、拥塞控制
1. 流量控制是控制发送的数据量，避免填满接收方的缓冲区，但是因为网络环境差可能导致数据包延时丢失，如果这个时候不停重传，会进一步导致网络负担更大，所以需要拥塞控制来根据网络状况调整发送数据量
2. 拥塞窗口是发送方用来调节数据发送量大小的参数cwnd，它由发送方控制，受网络状况影响，所以发送窗口的大小等于拥塞窗口和接收窗口的最小值
3. 拥塞窗口的规则就是网络状况好每次确认应答增加拥塞窗口；网络状况不好发生了重传，就减小拥塞窗口；有四种拥塞控制的算法：慢启动，拥塞避免，拥塞发送，快速恢复
4. 慢启动，linux有设置tcp的拥塞窗口初始值10（这里的数字的mss为单位）, 每接收到一个ack确认应答，cwnd+1，所以慢启动的滑动窗口是指数增加（因为每一次发生消息都是cwd次数个数据包）
4.1 当增加到一个阈值，慢启动门限ssthresh，会进入拥塞避免算法
5. 拥塞避免算法：当每接收到一个ack确认应答，cwnd增加1/cwnd个拥塞窗口大小，是线性增加
5.1 当出现重传，会进入拥塞发送算法，分两种情况，超时重传和快速重传
6. 超时重传，说明网络状况较差，会将慢启动门限sshthresh设置成cwnd的一半，把拥塞窗口恢复成初始值，然后进行慢启动
7. 快速重传，说明多个数据包只丢了部分包，网络状态没有太差，将cwnd设置成一半，慢启动门限设置成现在cwnd大小，进入快速恢复算法
8. 快速恢复，因为是快速重传导致的，会接收到3个ack包，cwnd+3，然后重传数据包，当收到重复的ack包，cwnd+1，也就是还有其他包丢失了，当收到数据的ack包，也就是已经重传完了，快速恢复结束，将cwnd设置成慢启动门限sshthresh，继续拥塞避免算法