redis有两种持久化技术：aof日志,rdb快照
aof: append only file，每执行修改命令，追加到aof文件
rdb：记录一瞬间的内存数据

一、aof
1. 流程：在主线程执行操作命令后，会将命令追加到aof缓冲区，然后会write到操作系统的page cache，经过一定时机fsync到磁盘
2. 写到磁盘的时机有三种配置；三种配置决定的是fsync调用的时机
2.1 always，每次修改命令都写入磁盘
2.2 eveysecs，开启异步任务每秒写入磁盘
2.3 no，不直接写入磁盘，写入到page cache,由操作系统决定写入磁盘中
3. 当aof文件过大会带来恢复时性能问题，可以手动 bgrewriteaof触发或者自动触发，自动触发的配置：
3.1 当前aof文件超过上次重写的大小百分比，默认100
3.2 当前aof文件大小超过上限值，默认64m
3.3 自动触发还要满足以下场景
3.3.1 当前没有执行bgsave或bgrewriteaof的子进程
3.3.2 当前没有执行save的主进程
3.3.3 当前集群没有正在进行集群切换或者故障转移
4. aof重写是读取当前所有的键值对，以一条命令记录到新的aof文件，然后将重写过程中的新修改再追加新aof，最后重命名替换旧的aof文件
4.1 重写文件会读所有key很消耗性能，所以是在主线程fork一个子线程执行的，并复制一份页表，记录了所有虚拟地址和物理地址的映射，也就是主线程子线程使用的同一个真实地址
4.2 因为使用同一个真实地址，当子进程重写过程中，如果主进程执行了修改命令，主进程会写时复制，会拷贝新数据到新的物理内存，然后写入到aof重写缓冲区；重写过程还是读的旧数据（子进程页表指向的是旧地址）
4.3 子进程重写完成后，会给主线程发信号，主线程接收到信号后
4.3.1 将aof重写缓冲区的命令追加到新aof
4.3.2 将新aof文件重命名，覆盖旧aof
4.4 即重写过程中，在主进程执行的有三步：fork子进程复制页表；主线程修改数据需要写时复制，复制一份新数据到新的地址；主线程接收信号处理重写过程中的命令

二、rdb
1. rdb快照是记录所有内存数据，所以恢复只需要读出数据，恢复比aof速度快；但因为是全量快照，快照数据慢不可能频繁执行，所以宕机丢失数据会更多
2. rdb快照有两个生成命令，save和bgsave
2.1 save是在主线程执行，会阻塞主线程
2.2 bgsave是主线程fork一个子线程执行，基本与aof一致，但是没办法将快照期间新的修改追加到rbd文件
3. rdb只能在redis启动时自动加载，没有提供手动加载的命令
4. rdb文件的调用时机，在配置文件中设置了：900秒内修改了至少一次，300秒内修改了至少10次，60秒内至少修改了一万次

三、混合持久化
1. rdb优点是恢复快，缺点是宕机丢失数据会比较多；aof相反
2. redis4.0提供了混合持久化的方法，混合持久化在aof重写过程：重写时，fork出来的子进程以rdb格式写入aof文件，在重写过程中新的修改以aof格式写入aof文件
3. 这种格式就是aof文件中前面大部分时rdb格式，后面小部分时aof格式;加载时速度快，且因为是基于aof，宕机丢失数据少

四、redis大key问题
* 大key问题是某个key的value比较大，所以本质上是大value问题；redis-cli --bigkeys可以查到
1. redis处理命令是单线程的，大key处理耗时较长，阻塞主线程
2. 大key占网络带宽，可能网络阻塞
3. 内存分布不均，redis集群slot分布均匀的情况，大key所在slot内存倾斜
4. 大key删除也慢，用del会阻塞；大key的删除办法4.0以前是渐进式删除，4.0有unlink
4.1 渐进式删除
4.1.1 hash：用hscan一次扫描一批key删除
4.1.2 set: 用sscan
4.1.3 list:ltrim
4.1.4 zset: zremrangebyrank
4.2 unlink异步删除，后台线程执行
4.3 4.0后支持lazy free，慢操作是异步的，会放在bio的单独的子线程执行
5. aof持久化问题，aof写磁盘策略如果是alawys，会阻塞主线程
6. aof重写和rdb快照fork子线程过程，会由主线程复制页表；子线程执行完之前，如果主线程修改了数据需要拷贝新的物理内存；大key可能照成阻塞
7. aof重写最后会由主线程将重写过程中新的修改写入到aof文件，如果涉及到大key，可能会照成阻塞