redis可以作为消息队列，但是与专业的消息队列还有些欠缺；当业务较轻可以选用redis

消息队列的特点：
1. 发布订阅
2. 消息有序、支持延时消费
3. 重复消费
4. 消息可靠性

一、 最简单的list
生产者lpush消息，消费者rpop消息
1. 阻塞等待：队列为空时消费者不能空转，使用阻塞式拉取消息 brpop

存在问题：
1. 不能重复消费：消费者拉取消息后就从list删除了，不支持多个消费者消费消息
2. 消息丢失：消费者拉取到消息后如果异常了，消息就丢失
3. 延时队列等功能没法实现

解决方案：
1. 通过备份队列来解决，每次读出时往备份队列写brpoplpush，当消费者消费成功时才删除，失败再次从备份队列rpush;

二、pub/sub发布订阅模型
redis提供了pub/sub命令，支持多消费者订阅消息，多生产者发送消息

存在问题：
1. 消息未持久化丢失：pub/sub只是一种命令，并不是数据类型，不支持数据持久化，如果redis宕机，数据就会丢失
2. 数据实时转发，就照成如果在生产者发布消息时某个消费者异常，再重新上线后只能接收到新消息；如果没有消费者，生产者的消息会丢失
3. 消息积压丢失：pub/sub模型底层实现会在server上给消费者开辟一个缓冲区，生产者发布消息会推送到缓冲区，缓冲区是有上限，超过上限redis会将消费者下线，消费者消费失败丢失数据（根本原因是pub/sub模型是推模型）
4. 同样延时队列等功能没法解决

三、有序集合zset

可以处理延时队列
1. zset插入数据时score为时间戳+延时时间，查询数据判断时间是否大于score

存在问题：
1. 只解决了延时队列，存在和list同样的问题

四、stream数据类型

redis5.0新增的数据类型stream
1. 支持阻塞式拉取消息 XREGE block 0
2. 支持发布、订阅模型，创建消费组，在指定消费组下拉取消息
3. 消息处理异常解决：消费者消费完消息后xack通知redis，redis会把消息标记处理完成，如果有消费者没处理成功，会重新发给消费者
4. 消息持久化：每个写操作会写入RDB和AOF
5. 消息堆积：当超过队列的最大长度，会丢掉旧消息；所以还是存在消息丢失

存在的问题：
1. 消息丢失：aof写盘异步，可能丢失消息；主从复制异步，可能丢失消息；消息堆积会丢失消息
2. 消息存放在内存，消息堆积对内存压力较大
