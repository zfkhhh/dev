一、数据类型
1. 常见的5种类型：string，list，map，set，zset；后续还新增了bitmap，steam等好几种，不常用
2. 使用场景
2.1 string类型常用与字符串缓存、session、分布式锁等
2.2 list常用于队列
2.3 map常用于对象存储
2.4 set常用与集合计算，交集、并集、差集，对应的场景如点赞、共同关注等
2.5 zset常用与排序场景，如排行榜、延长队列等
3. 底层结构
3.1 string底层是sds,简单动态字符串
3.2 list底层是压缩列表和双向链表,当元素小于512个且元素大小小于64字节使用压缩列表，超过使用双向链表；3.2换成了quicklist，quicklist底层是双向链表+压缩列表，链表每个元素是压缩列表
3.3 hash底层是压缩列表和hash表，当元素小于512个且元素大小小于64字节用压缩列表，超过用hash表；7.0压缩列表换成了listpack
3.4 set底层是整数集合和hash表，当集合元素都是整数且小于512个用整数集合，超过用hash表
3.5 zset底层使用压缩列表和跳表，当有序元素小于128个且元素大小小于64字节使用压缩列表，超过使用跳表；7.0压缩列表换成了listpack

二、redis存储key-value结构
1. redis本身通过hash表存放键值对，有两个hash桶，一个用来存放数据，一个用来rehash
2. hash桶存放了键值对对象的指针；键值对对象包括key指针和value指针，key指针指向string类型的数据，value指针对象包含对象结构类型，数据类型的底层结构，存放数据的指针

三、string
1. string类型底层是sds结构，类似与go中的string，底层包括字节数组、字符串长度、分配空间大小、sds类型
2. alloc分配空间大小用与修改字符串时，通过alloc-len计算剩余空间，判断能否满足修改需求，不满足会将sds空间扩展为所需的两倍
3. sds类型用于保存不同大小的字符串，如sdshdr5、8、16、32、64，用于优化空间对齐
4. 二进制安全：对于c语言，字符串的结尾需要\0来标志，这个限制使得c语言的字符串只能保存文本数据，不能保存像图片、音频、视频文化这样的二进制数据，而sds结构，用len保存了字符串长度，可以保存"\0"字符，所以可以保存任意二进制


四、list
1. 当元素小于512个且元素大小小于64字节使用压缩列表，超过使用双向链表，3.2换成了quicklist
2. 压缩列表是redis为了节省空间设计的结构体，是连续的内存块组成的顺序数据结构，它表头数据为列表长度、节点数量、列尾偏移量；节点的结构体包括上一节点长度，当前节点数据类型和长度，数据内容；
3. 节点的前一节点长度，如果前一节点小于254字节，会用1字节存放，大于会用5字节存放；这就会造成连锁更新的问题：当多个连续节点长度为253，在节点前插入一个超过254字节的节点，就会联动更新后续所有节点的长度；所以压缩列表虽然省空间，但是节点多或者节点大了，会多次重新分配空间甚至连锁更新，适用与节点少且空间小的场景
4. 双向链表就是指向前、后节点的指针和元素值
5. quicklist就是双向链表，每个链表节点是压缩列表；它在插入数据的时候，会检查对应节点上的压缩列表是否能加入，通过控制压缩列表的元素个数，减少连锁更新

五、hash
1. 当元素小于512个且元素大小小于64字节用压缩列表，超过用hash表；7.0压缩列表换成了listpack
2. hash表是一个数组，每个元素是指向节点的指针；指针包括当前键值和指向溢出的下一节点的指针（链式hash），当有节点加入时，计算键的hash值找到对应的hash桶插入，如果已存在元素既hash冲突，通过链式hash解决，既加入当前存在的节点next指针
3. 链式hash就会存在问题，随着元素增加链表长度太长，查询时间复杂度就是O(n)，解决办法就是rehash，新的hash表创建两倍的hash桶，重新hash计算迁移数据到新桶；因为迁移大量数据会阻塞redis，所以采用渐进式rehash，进行增删改查的时候会顺便将hash桶位置的所有键值对迁移到新桶，直到所有数据迁移完成
4. rehash的触发
4.1 负载因子大于1，且没有在执行rdb快照或者aof重写，会执行rehash
4.2 负载因子大于5，说明hash冲突非常严重，不管有没有在执行rdb快照或者aof重写，强制rehash
5. listpack用来代替压缩列表，它每个节点不再包括上一节点的长度，避免了连锁更新的问题

六、set
1. 当集合元素都是整数且小于512个用整数集合，超过用hash表
2. 整数集合是一个连续空间，结构包括编码格式、元素个数、数组；其中如果整数集合加入新元素，类型占用空间大于旧元素，如果int64加入int32的集合，需要升级整数集合，扩大数组空间，并将所有元素升级成int64，这样就节省了空间，只有在真正使用到int64类型数时才真正使用对应空间；不支持降级

七、zset
1. 当集合元素小于128且大小小于64字节，使用压缩列表，超过使用跳表；7.0压缩列表换成listpack
2. 跳表是一个多层的有序链表，结构体包含头尾节点，跳表长度与最大层数，跳表节点保存了一个level数组和权重，数组每个元素对应每层的前后指针和跨度；查询时能根据权重，直接跳到当前层的下一节点，时间复杂度为O(logn)，优化了链表的O(n)
3. 查询过程，遍历头节点的level数组，从最高层开始比较权重，如果权重小与查询节点权重，权重等于并且数据小与查找数据，就会进入当前层的下一节点；如果不满足或者下一节点为空就进入下一层
4. 跳表相邻节点的层数比例会很影响查询效率，最理想的比例是2:1;但是维护节点比例会照成额外的开销，redis创建节点的时候，采用随机层数，随机0到1，如果小于0.25就增加一层