基于redis的分布式锁

一. 加锁
`set key value nx px 1000`

nx 只有当key不存在时才能set成功，px超时时间

1. redis命令操作是单线程的，nx能保证只有一个服务能set成功
2. px保证死锁或者忘记解锁也能释放，避免死锁

二. 解锁
`del key`

但是可能会出现其他进程删错，需要保证解锁进程就是加锁进程，可以在value设置成进程唯一，先查value后删除，通过lua脚本保证原子性

`
if redis.call("get", key[1]) == args[1] then
    return redis.call("del", key[1])
else 
    return 0
end    
`

三. 不可重入

很明显，当前获得锁方式是不可重入的（同一进程不能多次获得锁）
如果需要改成可重入锁，需要改造加锁

加锁：


args 第一个参数requstID, 第二个参数超时时间
`
if redis.call("setnx", key[1], args[1]) == 1 then
    redis.call("expire", key[1], args[2])
elseif   redis.call("get", key[1]) == args[1] then  // 如果锁存在，判断是否当前进程的锁
    return 1
else 
    return 0    
end
`



四. 缺点

1. 超时时间不好设置，如果超时时间过短，进程a还在操作，进程b已经获得锁，导致分布式锁失效
解决：通过守护进程轮询锁的超时时间，当快超时时，续约超时时间

2. redis集群主从复制是异步的，如果还未同步完成完成master异常，新master没有key,造成多进程同时获得了锁
解决：红锁
机制：客户端需要和多个redis节点请求获得锁，如果半数以上获得成功且总耗时没有超过锁超时时间，认为是获得锁成功