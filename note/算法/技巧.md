1. 只出现一次的数字 https://leetcode.cn/problems/single-number/?envType=study-plan-v2&envId=top-100-liked
- 两个不同的数异或等于0，一个数异或0等于本身，数组所有数异或最后得到那个存在两次的数
`
func singleNumber(nums []int) int {
    res := 0
    for _, num := range nums {
        res ^= num
    }
    return res
}
`
2. 多数元素 https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked
- 投票法，因为存在一个超过半数的数，只需要不同数字相互抵消，最后剩下的就是超过半数的数
`
func majorityElement(nums []int) int {
    var majory, count int
    for _, v := range nums {
        if count == 0 {
            majory = v
            count = 1
            continue
        }
        if v == majory {
            count++
        } else {
            count--
        }
    }
    return majory
}
`
3. 颜色分类 https://leetcode.cn/problems/sort-colors/description/?envType=study-plan-v2&envId=top-100-liked
- 排序，但是因为数字的类型只有三个且固定顺序，枚举排序,设置头指针就可以做到时间复杂度为n
`
func sortColors(nums []int)  {
    var head int
    for i, v := range nums {
        if v == 0 {
            nums[i], nums[head] = nums[head], nums[i]
            head++
        }
    }
    for i, v := range nums {
         if v == 1 {
            nums[i], nums[head] = nums[head], nums[i]
            head++
        }
    }
    return
}
`