1. 岛屿数量 https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked
- dfs递归，往上下左右递归修改值，两层循环遍历找,dfs次数就是结果
`
func numIslands(grid [][]byte) (ans int) {
    m := len(grid)
    n := len(grid[0])
    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if grid[i][j] == '1' {
                ans++
                dfs(grid, i, j)
            }
        }
    }
    return
}
func dfs(grid [][]byte, row, col int) {
    m := len(grid)
    n := len(grid[0])
    if row < 0 || row >= m || col < 0 || col >= n || grid[row][col] != '1' {
        return 
    }
    grid[row][col] = '2'
    dfs(grid, row+1, col)
    dfs(grid, row-1, col)
    dfs(grid, row, col+1)
    dfs(grid, row, col-1)
}
`
2. 腐烂的橘子 https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked
- 多起点广度遍历,用栈存放腐烂的橘子，循环直到栈没有橘子
`
type position struct {
    x, y int
}
var directions = []position{ {0,-1},{0,1}, {1,0},{-1,0}}

func orangesRotting(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])
    stack := []position{}
    var num int
    for i := 0; i < m;i++ {
        for j :=0; j<n; j++ {
            if grid[i][j] == 1 {
                num++
            } 
            if grid[i][j] == 2 {
                stack = append(stack, position{x:i, y:j})
            }
        }
    }
    res := -1
    for len(stack) > 0 {
        res++
        temp := []position{}
        for _, p := range stack {
            // 四个方向设置
            for _, direct := range directions {
                x, y := p.x+direct.x, p.y+direct.y
                if x >= 0 && x <= m-1 && y >=0 && y <= n-1 && grid[x][y] == 1 {
                    num--
                    grid[x][y] = 2
                    temp = append(temp, position{x,y})
                }
            }
        }
        stack = temp
    }
    if num > 0 {
        return -1
    }
    return max(res, 0)
}

`