1. 反转链表
https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&envId=top-100-liked
- 借助一个pre头指针和指向下一节点的指针nxt
`
func reverseList(head *ListNode) *ListNode {
    var pre *ListNode
    cur := head

    for cur != nil {
        nxt := cur.Next
        cur.Next = pre
        pre = cur
        cur = nxt
    }
    return pre
}
`

2. 环形链表，判断是否存在环
https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked
- 用快慢指针，只要指针相遇了就存在环，如果走到链表尾没有相遇就没环
`
func hasCycle(head *ListNode) bool {
    slow, fast := head, head

    // 快指针一定能遇到慢指针
    for (fast != nil && fast.Next != nil) {
        slow = slow.Next
        if fast.Next != nil {
            fast = fast.Next.Next
        } else {
            break
        }

        if slow == fast {
            return true
        }
    }
    return false
}
`

3. 环形链表，获得环入口
https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&envId=top-100-liked
- 先快慢指针，走到相遇
- 慢指针和头节点指针同速度开始走，走到相遇就是入口(fast指针走过的节点数=slow指针走过的节点数*2，算出x=(n-1)(y+z)+z)
`
func detectCycle(head *ListNode) *ListNode {
    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            // 当相遇时，slow、header走最终相遇与入口
            for slow != head {
                slow = slow.Next
                head = head.Next
            }
            if slow == head {
                return slow
            }
        }
    }
    return nil
}
`

4. 删除链表的倒数第 N 个结点
https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-100-liked
- 顺序查询链表节点，当第n个结点，将next.next设置成next节点
`
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dm := &ListNode{Next: head}

    right := dm
    for n != 0 {
        n--
        right = right.Next
    }

    left := dm
    for right.Next != nil {
        right = right.Next
        left = left.Next
    }

    left.Next = left.Next.Next

    return dm.Next
}
`

5. k个一组翻转链表
https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked
- 关键是需要找到每次循环翻转的开始，结束位置，然后对这个子链表内结点进行翻转
`
func reverseKGroup(head *ListNode, k int) *ListNode {
    // 节点数
    n := 0
    
    cur := head
    for cur != nil {
        n++
        cur = cur.Next
    }

    dm := &ListNode{Next: head}
    p0 := dm

    for n >= k {
        n -= k

        var pre *ListNode
        cur := p0.Next 
        // k个节点翻转
        num := k
        for num > 0 {
            num--
            nxt := cur.Next
            cur.Next = pre
            pre = cur
            cur = nxt
        }
        // 将p0的nxt存下来
        nxt := p0.Next
        p0.Next.Next = cur
        p0.Next = pre

        p0 = nxt
    }
    return dm.Next
}
`