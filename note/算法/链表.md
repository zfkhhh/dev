1. 反转链表
https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&envId=top-100-liked
- 借助一个pre头指针和指向下一节点的指针nxt
`
func reverseList(head *ListNode) *ListNode {
    var pre *ListNode
    cur := head

    for cur != nil {
        nxt := cur.Next
        cur.Next = pre
        pre = cur
        cur = nxt
    }
    return pre
}
`

2. 环形链表，判断是否存在环
https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked
- 用快慢指针，只要指针相遇了就存在环，如果走到链表尾没有相遇就没环
`
func hasCycle(head *ListNode) bool {
    slow, fast := head, head

    // 快指针一定能遇到慢指针
    for (fast != nil && fast.Next != nil) {
        slow = slow.Next
        if fast.Next != nil {
            fast = fast.Next.Next
        } else {
            break
        }

        if slow == fast {
            return true
        }
    }
    return false
}
`

3. 环形链表，获得环入口
https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&envId=top-100-liked
- 先快慢指针，走到相遇
- 慢指针和头节点指针同速度开始走，走到相遇就是入口(fast指针走过的节点数=slow指针走过的节点数*2，算出x=(n-1)(y+z)+z)
`
func detectCycle(head *ListNode) *ListNode {
    slow, fast := head, head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {
            // 当相遇时，slow、header走最终相遇与入口
            for slow != head {
                slow = slow.Next
                head = head.Next
            }
            if slow == head {
                return slow
            }
        }
    }
    return nil
}
`

4. 删除链表的倒数第 N 个结点
https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/?envType=study-plan-v2&envId=top-100-liked
- 顺序查询链表节点，当第n个结点，将next.next设置成next节点
`
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dm := &ListNode{Next: head}

    right := dm
    for n != 0 {
        n--
        right = right.Next
    }

    left := dm
    for right.Next != nil {
        right = right.Next
        left = left.Next
    }

    left.Next = left.Next.Next

    return dm.Next
}
`

5. k个一组翻转链表
https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked
- 关键是需要找到每次循环翻转的开始，结束位置，然后对这个子链表内结点进行翻转
`
func reverseKGroup(head *ListNode, k int) *ListNode {
    // 节点数
    n := 0
    
    cur := head
    for cur != nil {
        n++
        cur = cur.Next
    }

    dm := &ListNode{Next: head}
    p0 := dm

    for n >= k {
        n -= k

        var pre *ListNode
        cur := p0.Next 
        // k个节点翻转
        num := k
        for num > 0 {
            num--
            nxt := cur.Next
            cur.Next = pre
            pre = cur
            cur = nxt
        }
        // 将p0的nxt存下来
        nxt := p0.Next
        p0.Next.Next = cur
        p0.Next = pre

        p0 = nxt
    }
    return dm.Next
}
`
6. 排序链表https://leetcode.cn/problems/sort-list/
- 采用归并排序，快排不太好处理指针移动
`
func sortList(head *ListNode) *ListNode {
	return sort(head, nil)
}
func sort(head, tail *ListNode) *ListNode {
	if head == nil {
		return head
	}
	// 断开两条链表
	if head.Next == tail {
		head.Next = nil
		return head
	}
	// 快慢指针拿到中间节点
	slow, fast := head, head
	for fast != tail {
		slow = slow.Next
		fast = fast.Next
		if fast != tail {
			fast = fast.Next
		}
	}
	mid := slow
	return mergesort(sort(head, mid), sort(mid, tail))
}
// 归并排序
func mergesort(head1, head2 *ListNode) *ListNode {
	dummyHead := &ListNode{}
	temp, temp1, temp2 := dummyHead, head1, head2
	for temp1 != nil && temp2 != nil {
		if temp1.Val < temp2.Val {
			temp.Next = temp1
			temp1 = temp1.Next
		} else {
			temp.Next = temp2
			temp2 = temp2.Next
		}
		temp = temp.Next
	}
	if temp1 != nil {
		temp.Next = temp1
	}
	if temp2 != nil {
		temp.Next = temp2
	}
	return dummyHead.Next
}
`
7. 相交链表 https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&envId=top-100-liked
- A,B链表首位相连，如果相交最终会走到相交节点，不相交会同时走到nil
`
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }
    a,b := headA, headB
    for headA != headB {
        if headA != nil {
            headA = headA.Next
        } else {
            headA = b
        }
        if headB != nil {
            headB = headB.Next
        } else {
            headB = a
        }
    }
    return headA
}
`