有十种经典的排序算法：冒泡排序、选择排序、插入排序、希尔排序、归并排序、快速排序、堆排序、计数排序、桶排序、基数排序

1、冒泡排序
`
func bubbleSort(arr []int) []int {
        length := len(arr)
        for i := 0; i < length; i++ {
                for j := 0; j < length-1-i; j++ {
                        if arr[j] > arr[j+1] {
                                arr[j], arr[j+1] = arr[j+1], arr[j]
                        }
                }
        }
        return arr
}
`
2、选择排序
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
重复第二步，直到所有元素均排序完毕。
`
func selectionSort(arr []int) []int {
        length := len(arr)
        for i := 0; i < length-1; i++ {
                min := i
                for j := i + 1; j < length; j++ {
                        if arr[min] > arr[j] {
                                min = j
                        }
                }
                arr[i], arr[min] = arr[min], arr[i]
        }
        return arr
}
`
3、插入排序
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置
`
func insertionSort(arr []int) []int {
        for i := range arr {
                preIndex := i - 1
                current := arr[i]
                for preIndex >= 0 && arr[preIndex] > current {
                        arr[preIndex+1] = arr[preIndex]
                        preIndex -= 1
                }
                arr[preIndex+1] = current
        }
        return arr
}
`
4、希尔排序
希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录"基本有序"时，再对全体记录进行依次直接插入排序
`
func shellSort(arr []int) []int {
	for d := len(arr) / 2; d > 0; d = d / 2 {
		for i := d; i < len(arr); i++ {
			for j := i; j >= d && arr[j-d] > arr[j]; j -= d {
				arr[j-d], arr[j] = arr[j], arr[j-d]
			}
		}
		fmt.Println(arr)
	}
	fmt.Println("--------------------------------")
	fmt.Println("排序后的数组：", arr)
	return arr
}
`
5、归并排序
6、快速排序
在冒泡排序基础上的递归分治法
从数列中挑出一个元素，称为 "基准"（pivot）;
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序
`
func quickSort(arr []int, left, right int) {
	if left >= right {
		return
	}
	i, j := left, right
	value := arr[i]
	for i < j {
		for i < j && arr[j] >= value {
			j--
		}
		arr[i] = arr[j]
		for i < j && arr[i] <= value {
			i++
		}
		arr[j] = arr[i]
	}
	arr[i] = value
	fmt.Println(arr)
	quickSort(arr, left, i-1)
	quickSort(arr, j+1, right)
}
`
7、堆排序
8、计数排序
9、桶排序
10、基数排序


