1. 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-100-liked
- 递归左右子树，每次递归+1
`
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    l_max := maxDepth(root.Left)
    r_max := maxDepth(root.Right)
    return slices.Max([]int{l_max, r_max}) + 1
}
`

2. 对称二叉树
https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-100-liked
- 递归二叉树，每次判断左右子结点是否相同
`
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return isSame(root.Left, root.Right)
}
func isSame(left, right *TreeNode) bool {
    if left == nil || right == nil {
        return left == right
    }
    // 轴对称： 左的右 和 右的左； 左的左和右的右
    return left.Val == right.Val && isSame(left.Right, right.Left) && isSame(left.Left, right.Right)
}
`
3. 层序遍历
https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked
- 借助两个临时变量当前层节点和下一层节点数组，每次遍历当前层节点数组得到下一层数组节点
`
func levelOrder(root *TreeNode) [][]int {
    res := make([][]int, 0)
    if root == nil {
        return res
    }
    // 当前层节点
    cur := []*TreeNode{root}
    // 下一层节点
    nxt := []*TreeNode{}
    for len(cur) != 0 {
        tmp := make([]int, 0)
        for _, node := range cur {
            tmp = append(tmp, node.Val)
            if node.Left != nil {
                nxt = append(nxt, node.Left)
            }
            if node.Right != nil {
                nxt = append(nxt, node.Right)
            }
        }
        res = append(res, tmp)
        cur = nxt
        nxt = []*TreeNode{}
    }
    return res
}
`
4. 验证二叉搜索树
https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked
- 校验子树节点值时，带入上一节点的数据，最大最小值
`
func isValidBST(root *TreeNode) bool {
    return check(root, math.Inf(-1), math.Inf(1))
}
func check(node *TreeNode, left, right float64) bool {
    if node == nil {
        return true
    }
    v := float64(node.Val)
    return left < v  && v < right && check(node.Left, left, v) && check(node.Right, v, right)
}
`
5. 二叉树的右视图
https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked
- 先创建一个全局的数组，数组顺序存每层最右节点，递归树，从右子树开始遍历，如果数组中当前层没有节点就加入
`
func rightSideView(root *TreeNode) []int {
    ans := make([]int, 0)
    if root == nil {
        return ans
    }
    ans = append(ans, root.Val)
    getRight(root.Right, &ans, 1)
    getRight(root.Left, &ans, 1)
    return ans
}
func getRight(node *TreeNode, ans *[]int, depth int) {
    if node == nil {
        return
    }
    if len(*ans) <= depth {
        *ans = append(*ans, node.Val)
    }
    getRight(node.Right, ans, depth+1)
    getRight(node.Left, ans, depth+1)
    return 
} 
`
6. 二叉树的最近公共祖先
https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked
- 递归当前节点的左右子树，返回的如果是nil说明子树上没有节点，在另一个子树上；左右子树都找到了说明当前节点就是最近公共祖先
`
 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    l := lowestCommonAncestor(root.Left, p, q)
    r := lowestCommonAncestor(root.Right, p, q)
    if left == nil { // 左子树没找到，在右子树
        return right
    }
    if right == nil { // 右子树没找到，在左子树
        return left
    }
    // 左右子树都找到了，说明当前节点就是最近公共祖先
    return root
}
`  
7. 前序、中序遍历序列构造二叉树 https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked
- 前序的第一个节点是子树的根节点，每次递归划分中序遍历的左右子树
`
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder) == 0 {
        return nil
    }
    var index int  // 将中序划分成左右子树
    for i, v := range inorder {
        if v== preorder[0] {
            index = i
            break
        }
    }
    root := &TreeNode{Val: preorder[0]}
    root.Left = buildTree(preorder[1:len(inorder[:index])+1], inorder[:index])
    root.Right = buildTree(preorder[len(inorder[:index])+1:], inorder[index+1:])
    return root
}
`
8. 路径总和 https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked
- 每次递归记录前缀和，计算满足v-targetSum的前缀和有多少数量的路径
- 最后要恢复数据，因为递归完左子树，再递归右子树的时候，不涉及左子树的任何节点，不减的话递归右子树数据会多
`
func pathSum(root *TreeNode, targetSum int) (res int) {
    dict := map[int]int{0:1}
    var dfs func(*TreeNode, int)
    dfs = func(node *TreeNode, v int) {
        if node == nil {
            return
        }
        v += node.Val
        res += dict[v-targetSum]
        dict[v]++ 
        dfs(node.Left, v)  // 往左右节点递归
        dfs(node.Right, v)
        dict[v]-- // 恢复数据
    }
    dfs(root, 0)
    return
}
`