1. 二叉树的最大深度
https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&envId=top-100-liked
- 递归左右子树，每次递归+1
`
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    l_max := maxDepth(root.Left)
    r_max := maxDepth(root.Right)
    return slices.Max([]int{l_max, r_max}) + 1
}
`

2. 对称二叉树
https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-100-liked
- 递归二叉树，每次判断左右子结点是否相同
`
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return isSame(root.Left, root.Right)
}

func isSame(left, right *TreeNode) bool {
    if left == nil || right == nil {
        return left == right
    }
    // 轴对称： 左的右 和 右的左； 左的左和右的右
    return left.Val == right.Val && isSame(left.Right, right.Left) && isSame(left.Left, right.Right)
}
`

3. 层序遍历
https://leetcode.cn/problems/binary-tree-level-order-traversal/description/?envType=study-plan-v2&envId=top-100-liked
- 借助两个临时变量当前层节点和下一层节点数组，每次遍历当前层节点数组得到下一层数组节点

`
func levelOrder(root *TreeNode) [][]int {
    res := make([][]int, 0)
    if root == nil {
        return res
    }
    // 当前层节点
    cur := []*TreeNode{root}
    // 下一层节点
    nxt := []*TreeNode{}
    for len(cur) != 0 {
        tmp := make([]int, 0)
        for _, node := range cur {
            tmp = append(tmp, node.Val)
            if node.Left != nil {
                nxt = append(nxt, node.Left)
            }
            if node.Right != nil {
                nxt = append(nxt, node.Right)
            }
        }
        res = append(res, tmp)
        cur = nxt
        nxt = []*TreeNode{}
    }
    return res
}
`

4. 验证二叉搜索树
https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked
- 校验子树节点值时，带入上一节点的数据，最大最小值
`
func isValidBST(root *TreeNode) bool {
    return check(root, math.Inf(-1), math.Inf(1))
}

func check(node *TreeNode, left, right float64) bool {
    if node == nil {
        return true
    }
    v := float64(node.Val)
    return left < v  && v < right && check(node.Left, left, v) && check(node.Right, v, right)
}
`

5. 二叉树的右视图
https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked
- 先创建一个全局的数组，数组顺序存每层最右节点，递归树，从右子树开始遍历，如果数组中当前层没有节点就加入
`
func rightSideView(root *TreeNode) []int {
    ans := make([]int, 0)

    
    if root == nil {
        return ans
    }
    ans = append(ans, root.Val)
    getRight(root.Right, &ans, 1)
    getRight(root.Left, &ans, 1)

    return ans
}

func getRight(node *TreeNode, ans *[]int, depth int) {
    if node == nil {
        return
    }

    if len(*ans) <= depth {
        *ans = append(*ans, node.Val)
    }

    getRight(node.Right, ans, depth+1)
    getRight(node.Left, ans, depth+1)

    return 
} 
`


6. 二叉树的最近公共祖先
https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked
- 递归根节点的左右子树，如果找的到就传入的p,q节点就返回根节点，对应返回左、右子树节点（说明在根节点的左右子树上）

`
 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q {
        return root
    }
    l := lowestCommonAncestor(root.Left, p, q)
    r := lowestCommonAncestor(root.Right, p, q)

    if l != nil && r != nil {
        return root
    }
    if l != nil {
        return l
    }
    return r
}
` 
