1. 最大子数组和
https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked
要找最大连续子数组的和，遍历数组的时候每次比较前面数组相加是否比当前元素大

`
func maxSubArray(nums []int) int {
    max := nums[0]
    for i := 1; i < len(nums); i++ {
        if nums[i] + nums[i-1] > nums[i] {
            nums[i] += nums[i-1]
        }
        if nums[i] > max {
            max = nums[i]
        }
    }
    return max
}
`

2. 轮转数组
https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked
轮转k位，先与数组大小取模，分成三次反转，先反转整个数组，然后反转前k位，后len-k位
`
func rotate(nums []int, k int)  {
    n := len(nums)
    if k >=  n {
        k = k % n
    }
    reverse(nums)
    reverse(nums[:k])
    reverse(nums[k:])

}

// 翻转数组
func reverse(nums []int) {
    for i := 0; i < len(nums)/2; i++ {
        nums[i],nums[len(nums)-i-1] = nums[len(nums)-i-1],nums[i]
    }
}
`

3. 合并区间
https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked
- 存第一个数组，后续遍历每次比较res[l-1][1]和当前数组的左边界
`
func merge(intervals [][]int) [][]int {
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})
	res := make([][]int, 0)
    for _, arr := range intervals {
        l := len(res)
        if l == 0 {
            res = append(res, arr)
            continue
        }
        if res[l-1][1] >= arr[0] {
            res[l-1][1] = slices.Max([]int{res[l-1][1], arr[1]})
        } else {
            res = append(res, arr)
        }
    }
	return res
}
`
4. 除自身以外的数组乘积 https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-100-liked
- 用前缀和和后缀和，除自身外的乘积就是当前数的前缀和和后缀和
`
func productExceptSelf(nums []int) []int {
    n := len(nums)
    preArr, sufArr := make([]int, n), make([]int, n)
    preArr[0] = nums[0]
    sufArr[n-1] = nums[n-1]
    for i := 1; i < n; i++ {
        preArr[i] = preArr[i-1] * nums[i]
    }
    for i := n-2; i > 0; i-- {
        sufArr[i] = sufArr[i+1] * nums[i]
    }
    answer := make([]int, n)
    answer[0] = sufArr[1]
    answer[n-1] = preArr[n-2]
    for i := 1; i < n-1; i++ {
        answer[i] = preArr[i-1] * sufArr[i+1]
    }
    return answer
}
`
5. 寻找旋转排序数组中的最小值 https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/submissions/571049899/
- 比较mid与最后一个数的大小，如果>最后一个数,当前数在第一个递增数组，最小数在mid-right；<=最后一个数，当前数在第二个递增数组，在left-mid
`
func findMin(nums []int) int {
    n := len(nums)
    left,right := 0,n-1
    for left <= right {
        mid := (left+right)/2
        if nums[mid] > nums[n-1] {  // 如果>最后一个数,最小数在mid-right
            left = mid + 1
        } else {  // <=最后一个数，在left-mid
            right = mid - 1
        }
    }
    return nums[left]
}
`
6. 搜索旋转排序数组 https://leetcode.cn/problems/search-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-100-liked
- 先找到最小值下标，将数组分为两个递增数组
- 如果target大于最后一个数，在0-(minIndex-1)这个递增数组内；如果target小于等于最后一个数，在minIndex-(n-1)这个递增数组内
`
func search(nums []int, target int) int {
    n := len(nums)
    // 找到最小值下标
    minIndex := findMin(nums)
    // 如果target大于最后一个数，在0-(minIndex-1)这个递增数组内
    var left, right int
    if target > nums[n-1] {
        left, right = 0, minIndex-1
    } else {
        // 如果target小于等于最后一个数，在minIndex-(n-1)这个递增数组内
        left, right = minIndex, n-1
    }
    index := binarySearch(nums, left, right, target)
    if nums[index] != target {
        return -1
    }
    return index
}
func findMin(nums []int) int {
    n := len(nums)
    left,right := 0,n-1
    for left <= right {
        mid := (left+right)/2
        if nums[mid] > nums[n-1] {  // 如果>最后一个数,最小数在mid-right
            left = mid + 1
        } else {  // <=最后一个数，在left-mid
            right = mid - 1
        }
    }
    return left
}
func binarySearch(nums []int, left, right, target int) int {
    for left <= right {
        mid := (left+right)/2
        if nums[mid] < target {
            left = mid + 1
        }else {
            right = mid - 1
        }
    }
    return left
}
`