1. 最大子数组和
https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked
要找最大连续子数组的和，遍历数组的时候每次比较前面数组相加是否比当前元素大

`
func maxSubArray(nums []int) int {
    max := nums[0]
    for i := 1; i < len(nums); i++ {
        if nums[i] + nums[i-1] > nums[i] {
            nums[i] += nums[i-1]
        }
        if nums[i] > max {
            max = nums[i]
        }
    }
    return max
}
`

2. 轮转数组
https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked
轮转k位，先与数组大小取模，分成三次反转，先反转整个数组，然后反转前k位，后len-k位
`
func rotate(nums []int, k int)  {
    n := len(nums)
    if k >=  n {
        k = k % n
    }
    reverse(nums)
    reverse(nums[:k])
    reverse(nums[k:])

}

// 翻转数组
func reverse(nums []int) {
    for i := 0; i < len(nums)/2; i++ {
        nums[i],nums[len(nums)-i-1] = nums[len(nums)-i-1],nums[i]
    }
}
`

3. 合并区间
https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked
- 存第一个数组，后续遍历每次比较res[l-1][1]和当前数组的左边界
`
func merge(intervals [][]int) [][]int {
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})
	res := make([][]int, 0)
    for _, arr := range intervals {
        l := len(res)
        if l == 0 {
            res = append(res, arr)
            continue
        }
        if res[l-1][1] >= arr[0] {
            res[l-1][1] = slices.Max([]int{res[l-1][1], arr[1]})
        } else {
            res = append(res, arr)
        }
    }
	return res
}
`
4. 除自身以外的数组乘积 https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-100-liked
- 用前缀和和后缀和，除自身外的乘积就是当前数的前缀和和后缀和
`
func productExceptSelf(nums []int) []int {
    n := len(nums)
    preArr, sufArr := make([]int, n), make([]int, n)
    preArr[0] = nums[0]
    sufArr[n-1] = nums[n-1]
    for i := 1; i < n; i++ {
        preArr[i] = preArr[i-1] * nums[i]
    }
    for i := n-2; i > 0; i-- {
        sufArr[i] = sufArr[i+1] * nums[i]
    }
    answer := make([]int, n)
    answer[0] = sufArr[1]
    answer[n-1] = preArr[n-2]
    for i := 1; i < n-1; i++ {
        answer[i] = preArr[i-1] * sufArr[i+1]
    }
    return answer
}
`