1. 最大子数组和
https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked
要找最大连续子数组的和，遍历数组的时候每次比较前面数组相加是否比当前元素大

`
func maxSubArray(nums []int) int {
    max := nums[0]
    for i := 1; i < len(nums); i++ {
        if nums[i] + nums[i-1] > nums[i] {
            nums[i] += nums[i-1]
        }
        if nums[i] > max {
            max = nums[i]
        }
    }
    return max
}
`

2. 轮转数组
https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked
轮转k位，先与数组大小取模，分成三次反转，先反转整个数组，然后反转前k位，后len-k位
`
func rotate(nums []int, k int)  {
    n := len(nums)
    if k >=  n {
        k = k % n
    }
    reverse(nums)
    reverse(nums[:k])
    reverse(nums[k:])

}

// 翻转数组
func reverse(nums []int) {
    for i := 0; i < len(nums)/2; i++ {
        nums[i],nums[len(nums)-i-1] = nums[len(nums)-i-1],nums[i]
    }
}
`

3. 合并区间
https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked
- 存第一个数组，后续遍历每次比较res[l-1][1]和当前数组的左边界
`
func merge(intervals [][]int) [][]int {
	sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})
	res := make([][]int, 0)
    for _, arr := range intervals {
        l := len(res)
        if l == 0 {
            res = append(res, arr)
            continue
        }
        if res[l-1][1] >= arr[0] {
            res[l-1][1] = slices.Max([]int{res[l-1][1], arr[1]})
        } else {
            res = append(res, arr)
        }
    }
	return res
}

`