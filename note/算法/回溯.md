1. 所有可能的子集
https://leetcode.cn/problems/subsets/description/?envType=study-plan-v2&envId=top-100-liked
- 从数组第一个元素开始递归，每个元素有选择和不选两种情况，两种递归
`
func subsets(nums []int) (res [][]int) {
    path := make([]int, 0)
    var dfs func(int) 
    dfs = func(cnt int) {
        if cnt == len(nums) {
            res = append(res, append([]int{}, path...))
            return
        }
        path = append(path, nums[cnt])
        dfs(cnt+1)
        path = path[:len(path)-1]
        dfs(cnt+1)
    }
    dfs(0)
    return
}
`

2. 电话号码的字母组合
https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?envType=study-plan-v2&envId=top-100-liked
- 对于传入的数字列表，每个数字对应多个字符，每个数字都有多个选项，递归所有选项
`
var mapping = map[string]string{
	"0": "",
	"1": "",
	"2": "abc",
	"3": "def",
	"4": "ghi",
	"5": "jkl",
	"6": "mno",
	"7": "pqrs",
	"8": "tuv",
	"9": "wxyz",
}
func letterCombinations(digits string) []string {
	res := make([]string, 0)

	var getv func(int)
	var path string
	getv = func(index int) {
		if index == len(digits) {
            if path != "" {
	            res = append(res, path)
            }
			return
		}

		v, exist := mapping[string(digits[index])]
		if !exist || len(v) == 0 {
			return
		}

		for _, c := range v {
			// 每个字符都是一种可能
			path = fmt.Sprintf("%s%s", path, string(c))
			getv(index + 1)
			path = path[:len(path)-1]
		}
		return
	}
	getv(0)
	return res
}
`
3. 全排列
https://leetcode.cn/problems/permutations/description/
- 
`
func permute(nums []int) (ans [][]int) {
    n := len(nums)
    path := make([]int, n)
    onPath := make([]bool, n)
    var dfs func(int)
    dfs = func(i int) {
        if i == n {
            ans = append(ans,  append([]int(nil), path...)) // 复制切片数据
            return
        }
        for j, on := range onPath {
            if !on {
                path[i] = nums[j]
                onPath[j] = true
                dfs(i + 1)
                onPath[j] = false
            }
        }
    }
    dfs(0)
    return
}
`