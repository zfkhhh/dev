1. 打家劫舍
https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked
核心思想：每个房子都有偷和不偷两种选择，偷的话最大值是n-2的值+当前值，不偷是n-1的值，也就是需要比较这两个值；通过递归得到所有可能的计算


一种简单理解的方法：递归+map保存计算结果
`
func rob(nums []int) int {
   cache := make(map[int]int)
   return get(len(nums)-1, nums, cache)
}


func get(n int,nums []int, cache map[int]int) int {
    if n < 0 {
        return 0
    }
    if v, exist := cache[n]; exist{
        return v
    }
    res := slices.Max([]int{get(n-1, nums, cache),get(n-2, nums, cache)+nums[n]})
    cache[n] = res
    return res
}
`

一种难理解的方法: 每次计算都是n-2,n-1,n这三个数比较，用两个临时变量记录
`
func rob(nums []int) int {
   a, b := 0, 0
   for _, v := range nums {
        a, b =  b, slices.Max([]int{a+v,b})
   }
    return b
}
`

2. 完全平方数
https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&envId=top-100-liked
用一个数组表示数字大小需要的完全平方数个数
`
func numSquares(n int) int {
    res := make([]int, n+1)
    for i := 1; i < n+1; i++ {
        minV := math.MaxInt32
        for j := 1; j*j <= i; j++ {
            minV = slices.Min([]int{minV, res[i-j*j]})
        }
        res[i] = minV + 1
    }
    return res[n]
}
`