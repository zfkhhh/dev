1. 打家劫舍
https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&envId=top-100-liked
核心思想：每个房子都有偷和不偷两种选择，偷的话最大值是n-2的值+当前值，不偷是n-1的值，也就是需要比较这两个值；通过递归得到所有可能的计算
一种简单理解的方法：递归+map保存计算结果
`
func rob(nums []int) int {
   cache := make(map[int]int)
   return get(len(nums)-1, nums, cache)
}
func get(n int,nums []int, cache map[int]int) int {
    if n < 0 {
        return 0
    }
    if v, exist := cache[n]; exist{
        return v
    }
    res := slices.Max([]int{get(n-1, nums, cache),get(n-2, nums, cache)+nums[n]})
    cache[n] = res
    return res
}
`
一种难理解的方法: 每次计算都是n-2,n-1,n这三个数比较，用两个临时变量记录
`
func rob(nums []int) int {
   a, b := 0, 0
   for _, v := range nums {
        a, b =  b, slices.Max([]int{a+v,b})
   }
    return b
}
`
2. 完全平方数
https://leetcode.cn/problems/perfect-squares/?envType=study-plan-v2&envId=top-100-liked
用一个数组表示数字大小需要的完全平方数个数
`
func numSquares(n int) int {
    res := make([]int, n+1)
    for i := 1; i < n+1; i++ {
        minV := math.MaxInt32
        for j := 1; j*j <= i; j++ {
            minV = slices.Min([]int{minV, res[i-j*j]})
        }
        res[i] = minV + 1
    }
    return res[n]
}
`
3. 零钱兑换
https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked
无限背包问题，每次选择都有硬币类型种，直到凑齐总金额数；用二维数组，行表示硬币类型数，列表示总金额，数组每个元素表示在当前金额需要用到的最小硬币数
`
func coinChange(coins []int, amount int) int {
	n := len(coins)
	res := make([][]int, n+1)
	for i := range res {
		res[i] = make([]int, amount+1)
		for j := range res[i] {
			res[i][j] = math.MaxInt / 2
		}
	}
	res[0][0] = 0
	for i, v := range coins {
		for j := 0; j < amount+1; j++ {
			if j < v {
				// 剩余金额不够使用当前硬币
				res[i+1][j] = res[i][j]
			} else {
				res[i+1][j] = min(res[i][j], res[i+1][j-v]+1)
			}
		}
	}
	v := res[n][amount]
	if v < math.MaxInt/2 {
		return v
	} else {
		return -1
	}
}
`

4. 单词拆分
https://leetcode.cn/problems/word-break/description/?envType=study-plan-v2&envId=top-100-liked
无限背包问题，只是需要判断字符串中某段是否中字典中存在，循环每个字符，判断字符前是否存在
`
func wordBreak(s string, wordDict []string) bool {
	dict := make(map[string]bool)
	for _, v := range wordDict {
		dict[v] = true
	}
	res := make([]bool, len(s)+1)
	res[0] = true
	for i := 0; i < len(s)+1; i++ {
		for j := 0; j < i; j++ {
			if res[j] && dict[s[j:i]] {
				res[i] = true
				break
			}
		}
	}
	return res[len(s)]
}
`

5. 最长递增子序列
https://leetcode.cn/problems/longest-increasing-subsequence/?envType=study-plan-v2&envId=top-100-liked
遍历数组，从当前数前到子数组里找到小与当前数的值，获得这个数的最长递增子序列元素个数
`
func lengthOfLIS(nums []int) int {
    n := len(nums)
    res := make([]int, n)
    for i :=0; i < len(nums); i++ {
        for j := 0;j < i;j++ {
            if nums[j] < nums[i] {
                res[i] = slices.Max([]int{res[j], res[i]})
            }
        }
        res[i]++
    }
    return slices.Max(res)
}
`
6. 乘积最大子数组
https://leetcode.cn/problems/maximum-product-subarray/?envType=study-plan-v2&envId=top-100-liked
因为数组的数有正有负，需要同时记录数组每n元素的最大值最小值
`
func maxProduct(nums []int) int {
    n := len(nums)
    maxL := make([]int, n)
    minL := make([]int, n)
    for i,v := range nums { // 先将nums数据复制到maxL, minL
        maxL[i],minL[i] = v,v
    }
    for i:= 1; i < n; i++ {
        v := nums[i]
        maxL[i] = slices.Max([]int{maxL[i-1]*v, minL[i-1]*v, v})
        minL[i] = slices.Min([]int{minL[i-1]*v, maxL[i-1]*v, v})
    }
    return slices.Max(maxL)
}
`

7. 解决智力问题
https://leetcode.cn/problems/solving-questions-with-brainpower/description/?envType=study-plan-v2&envId=dynamic-programming
这道题是01背包问题，循环题目，是否解决当前题，解决就可以得到res[i+q[1]+1]的分数的一种可能，不解决就能得到下一道题的分数都一种可能
`
func mostPoints(questions [][]int) int64 {
    n := len(questions)
    res := make([]int, n+1)
    for i,q := range questions {
        // 跳过这道题
        res[i+1] = slices.Max([]int{res[i+1], res[i]})
        // 不跳过
        j := i + q[1] + 1
        if j  > n {
            j = n
        }
        res[j] = slices.Max([]int{res[j], res[i] + q[0]})
    }
    return int64(res[n])
}
`
8.最长有效括号 https://leetcode.cn/problems/longest-valid-parentheses/description/
- 用栈解决，每次左括号加入，右括号取出，这样保证栈里面是连续的没有成对的左括号，出现右括号时取出栈里的左括号匹配
- 如果栈是空的将当前序号加入，是为了计算区间大小
`
func longestValidParentheses(s string) (res int) {
    stack := make([]int, 0, len(s))
    stack = append(stack, -1)
    for i, c := range s {
        if c == '(' {
            stack = append(stack, i)
            continue
        }
        stack = stack[:len(stack)-1]
        if len(stack) == 0 {
            stack = append(stack, i)
        } else {
            res = max(res, i-stack[len(stack)-1])
        }
    }
    return
}
`