一、消息模型
1. 消息队列有两种消息模型：队列模型、发布订阅模型
2. 队列模型：存在一个队列，n个生产者、消费者，生产者往队列push消息，多个消费者竞争消息，一个消息只能有一个消费者消费
3. 发布订阅模型：生产者称为publisher，消费者称为subscriber,服务端将消息存放在topic,消费者订阅topic，订阅者都可以消费到topic到消息

二、rocketmq的消息模型与消费模式
1. rocketmq是发布订阅模型，消费模式有两种：集群消费、广播消费
2. 集群消费：消息只能被订阅topic的消费组内的一个消费者消费，也就是消息被负载均衡到消费组的某一个消费者
2.1 消息的重试并不能保证发到原来的消费者
2.2 消费组内的消费者必须消费类型相同，不同会全按广播模式消费
3. 广播消费：消息会广播给订阅topic的消费组内的所有消费者消费，保证消息被所有消费者至少消费一次
3.1 消息并不会重试，需要注意消息的失败情况
3.2 消息服务端不会记录消息消费进度，由消费者各自保存消费进度

三、rocketmq的架构
1. rocketmq由四部分组成：nameserver，producer，consumer，broker;分别是服务发现，生产消息，消费消息，存储消息
2. namserver：服务注册与发现
2.1 管理broker节点信息，保持与broker的长链接，监控更新broker节点实时状态，进行路由注册、删除
2.2 为producer和consumer提供关于topic对应broker节点信息
3. broker：消息存储与中转
3.1 每个broker包含一个broker master和至少一个broker slave，保持主从结构，可以往master生产消费消息，slave只能消费消息
3.2 broker可以保存多个topic，topic内有多个queue，可以分布在多个broker，消息发送到topic中的queue
3.3 queue中存放消息索引，真正的消息存放在commitlog
3.4 单个broker与所有nameserver保持长链接和心跳，定时上报topic信息
4. producer提供三种消息发送模式
4.1 同步：消息发送完成要等到消费者响应才发送下一个消息
4.2 异步：消息发送不等响应，接着发下一个消息
4.3 单向：生产者只发送消息不等响应或者不提供回调函数
5. consumer有两种获取消息方式，pull和push，消费模式有集群消费和广播消费


四、rocketmq保证消息的可靠性不丢失
1. 消息的可靠性分为三部分：生产者到broker；broker自身的存储；broker到消费者
2. 生产者到broker：同步/异步+重试+多master
2.1 生产者有三种发送模式：同步、异步、单向；单向是不可靠到；同步立即能获得消息发送状态，异步通过回调函数获得发送状态
2.2 重试策略：可以配置重试次数，默认三次，当发送失败或超时时重试
2.3 broker采用多主模式，尽量一个topic分布在多个broker，如果一个broker宕机重试时可以选择其他broker
3. broker消息存储分为消息刷盘和主从同步问题
3.1 消息刷盘：分为同步刷盘和异步刷盘，当消息到broker，会先存到操作系统的page cache,根据刷盘策略决定是否立即刷盘
3.2 主从同步双写：可以设置消息发送到broker，必须完成写入到主从节点才成功
4. broker到消费者：消费者at least once;消费消息重试
4.1 at least once：消费者先pull消息到本地，消费成功后才返回ack
4.2 rocketmq提供消费者重试，但是广播消费模式需要消费者提供消费进度

五、rocketmq保证消息事务性
1. 根据半消息，通过消息的二次确认和消息回查实现分布式事务；半消息指的是暂时不能被消费者消费的消息，需要生产者端执行完本地事务后二次确认才能消费
2. 生产者开启事务，先发送半消息给broker，收到响应后，执行生产者本地事务；正常情况是生产者本地事务执行完成，发送commit或者rollback给broker，表示成功或者回滚
3. 异常情况，broker超时没有获得生产者事务状态，会回查事务状态，如果是未知，就继续按一定重试频率重试查询事务，直到超过次数就判断事务失败，rollback；如果查询到状态，就commit/rollback
4. 当消息是commit状态，消费者可见，执行消费者的本地事务，消费者消费成功返回ack，失败就出发rocketmq重试发送消息

六、死信队列
1. 消息消费失败rocketmq提供重试，当超过最大次数，表明消费者无法正常消费该消息，会将该消息放到消费组的一个特殊队列，死信队列
2. 死信队列：消费者不会消费该队列的消息，有效期和正常消息相同3天
3. 死信队列和topic没关系，一个死信队列对应一个消费组，保存了消费组的所有死信消息，当消费组没有死信消息不会创建死信队列

七、队列消息顺序
1. topic是多queue的，且分布在不同broker，支持生产者组和消费者组，所以要保证消息的顺序，需要加一些限制
2. 消息的顺序需要有限制：
2.1 消息生产的顺序：只能由一个生产者生产消息，不能用生产者组并发生产，也就是需要保证业务在一个pod中串行执行
2.2 消息出入队列的顺序：消息要按先进先出顺序出入队列，这需要保证在一个topic的一个queue中，也就是需要指定topic，然后id取模指向同一个queue
2.3 消息存储的顺序性：消息会持久化到磁盘，为了后续顺序消费需要保证持久化时也是有序的；在rokectmq中一个consumerqueue一个文件，保证好消息是同一queue，持久化就是有序的
2.4 消息消费的顺序：也就是需要保证消费组顺序消费消息，一个方法是只有一个消费者消费自然是顺序的，一个方法是rocketmq的messageListenerOrderly，有序消费模式，通过分布式锁和本地锁保证只有一个线程消费一个队列的消息，broker的分布式锁,messageQueue的本地sync锁，ProcessQueue的本地consumerLock



八、延时队列
1. rocketmq对延时队列处理的并不好，它是通过临时存储+定时任务实现的
2. 临时存储：broker在接收到延时消息，往延时topic发送消息，对应的queue为延时等级-1，相同的queue只有同样延时级别的延时消息，会根据存储时间+延时等级时间存放在queue
3. rocketmq定死了18个延时级别，在broker启动时会创建级别个数的定时器，轮询对应的queue，当消息到期会再存储到commitlog，并投递到对应的topic，消费者消费消息

九、文件存放
1. rocketmq存储文件分为commitlog，consumerqueue，indexfile
2. commitlog是真实存放消息数据的文件，存放了消息主体和元数据，消息顺序写入文件，单个文件为1g，超过自动创建新文件
3. consumerqueue，因为commitlog中存放的所有topic的消息，消费者查询消息遍历查找会很耗性能，所以用consumerqueue逻辑队列，存放topic下队列中消息的偏移量offset，消息大小和消息tag的hashcode
4. indexfile,存放了数据的索引，可以通过key或者时间查询消息