一、golang本身无法实现热更新
golang本身是一种静态的、编译型语言；它需要先编译成机器代码才能运行
golang代码层面的热更新，有一种实验特性plugin技术，但plugin十分鸡肋，它只能加载不能卸载且加载的内容无法更新，比如加入的新的plugin但是实际运行的还是旧的plugin

一个完整的有状态游戏服务器包括：代码、数据、配置；代码热更新golang语言做不到，配置热更新的做法就是文件监听，reload内存中的数据
而游戏的热更新指的就是数据热修复

二、应用层做到热更新
实际上还是需要服务重启，只是数据热修复，将游戏内的用户重要数据持久化到文件，再重启后恢复游戏状态

1. 每个游戏会有多个一个进程，进程内有256个桌子协程，用户游戏数据就保存在桌子对象内
2. 链接服务器的数据中转流程：会保存所有游戏进程的连接在连接池，客户端发送的数据包到链接服务器，链接服务器根据数据包中的服务器id拿出一个到该游戏服务的链接，发送数据包
3. 当更新游戏时，检查所有游戏进程中是否存在用户正在游玩
3.1 不存在用户的进程，通过ssh到该机器，调用supervisor重启进程
3.2 存在用户的进程，将对应的桌子对象序列化到文件，重启进程，在重启过程中，会关闭与链接服务器的连接，重启完成后
3.2.1 需要发起与所有链接服务器的链接并发送请求确认
3.2.2 需要反序列化文件保存的桌子对象，将其恢复到桌子协程
3.2.2.1 需要恢复的用户数据：恢复游戏规则配置、游戏状态机当前状态、游戏局数及分数信息
3.2.2.2 如果在游戏准备阶段：广播其他玩家的准备信息，如果是自动准备就延迟1秒自动帮玩家准备
3.2.2.3 如果在游戏行牌阶段：通知游戏开始，如果是游戏在买分阶段下发买分信息，如果是游戏在换牌阶段下发换牌信息、杠后打骰信息，下发精牌、手牌、牌堆数据，下发报听状态，如果处在吃碰杠权限选择阶段重新发送吃碰杠权限，下发用户操作通知

存在问题：
1. 重启过程中，用户进入游戏怎么办？
正常流程选择游戏服务器即可，就算是旧配置的游戏也会更新成新配置

2. 恢复桌子过程出问题？
2.1 与链接服务器重连失败，也就是丢失了这个线程，这个游戏线程下的所有用户请求都会报错，直到重连成功
2.2 恢复桌子失败，会报错或者游戏进行中的数据丢失
2.3 用户体验会感觉到卡顿

尽量选择用户少的时间更新，或者选择时间点清退所有用户更新