一、预读失效与缓存污染与mysql,redis,linux解决
1、预读失效：通常查询磁盘数据的时候，基于空间局部性原理，会将查询数据附近空间的数据一起读出放到内存中，如果预读的数据一直没用到，就是预读失效
2. 缓存污染：一次批量查大量数据，挤掉了热点缓存
3. 解决这两个问题，就是改进lru算法
4. redis没有缓存预读，通过lfu算法，在lru的基础上加入频率，解决缓存污染的问题，大量数据加入到处内存淘汰，热点数据因为频率大，不会被淘汰
5. linux是对读取的文件数据的缓存，会缓存在文件系统的page cache；mysql的innodb引擎设计了buffer pool缓存数据页，查询优先查询缓存数据页，没查到查磁盘会写回缓存数据页，写数据是写到buffer pool数据页，由后台线程写到磁盘

二、如何解决缓存预读失效
1. 传统lru是一个链表，按照最后一次访问时间来排序，当数据被访问会移动到链表头，当数据插入会将链表尾部的数据移除
2. 预读失效会导致预读的数据在lru链表头部，就会挤占热点数据
3. 解决的思路就是让预读的数据在缓存的数据尽量短，只有真正被访问的数据才加到lru表头
3.1 linux使用的两个链表，active_list活跃lru链表和inactive_list非活跃链表，预读数据先加入到inactive_list头部，当真正被访问时才加入到active_list；当数据页加入到active_list，active_list尾的数据会降级到inactive_list作为头部
3.2 mysql将lru链表分为两部分，young和old区，young区在lru链表前半段，old在后半段，并且比例是63:37，每个区都有自己的头尾节点；预读的数据先加入old头部，当真正被访问才加入到young

三、如何解决缓存污染
1. 思路就是加大进入活跃区的门槛，数据就算被批量访问了也不会直接到活跃区
2. linux是当数据页被访问第二次，才会从inactive_list移动到active_list头部
3. mysql是当数据页被访问第二次时，还要满足第一次到第二次访问间隔超过1s

