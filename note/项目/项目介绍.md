一、权限系统
1. 第一个从0到1的系统，为公司二十多个中台做权限控制，接口鉴权；涉及到用户、角色授权，权限点与接口匹配
2. 选用csbin框架的rbac模型，opa vs casbin；当前系统基于oa的账号角色体系，处理菜单权限、数据权限的需求，功能较单一；选用casbin
2.1 opa使用于大量api请求，策略需要扩展变化较多的场景，如果微服务、网关，它做的是系统请求时携带opa，opa会返回决策结果；它将系统各处的策略控制，比如用户权限控制、创建资源校验、某个时间允许访问等统一访问opa
2.2 casbin适用于策略模版固定，追求简单易用的场景，先定义访问控制模型与策略规则，会将权限数据持久化到redis或者mysql
3. 访问控制模型定义了系统、权限集、类型与对象层次，访问规则也就是系统层级，相同权限集下，用户的权限匹配成功
4. 接口鉴权是基于权限控制，通过匹配访问接口获得接口信息，检查接口绑定的权限点集合，用户是否拥有这些权限中的一个
4.1 考虑用radix前缀树保存接口数据，因为存在restful风格的接口，需要匹配通配符
4.2 本地lru缓存接口信息，因为接口信息变动较少，设置1分钟缓存，不做watcher机制
4.3 接口鉴权先匹配接口在系统的radix树中，存在就查询绑定的权限点，判断用户是否拥有这些权限点中的一个
5. 权限信息用本地lru缓存加etcd watcher机制，casbin注册了watcher后，修改数据时其他节点会监听到etcd数据的变更，重新生成本地lru中的数据

二、部署系统
1. 游戏热更新：热更新其实就是重启游戏线程，然后将数据恢复，这里的数据是线程内存在用户的桌子对象，上面保存着用户信息，当前游戏局内规则，游戏进行中的数据（排堆手牌，换牌买分，用户吃碰杠响应）等等，重启还会造成与连接管理connectsrv断连
2. 因为牌桌在redis中记录了回放数据，回放数据包含了上面需要的数据，用回放数据恢复桌子；保持同样的destId；在客户端发送包到connectsrv转发给游戏进程失败后，会返回错误，客户端重发消息直到游戏进程重启成功
3. 回放数据：有两种数据，一个是基础数据包括游戏规则，牌桌用户信息（sessionId，connectsrvId，socketCtx游戏信息等），一个是发送的消息；会先存放到内存的replay对象的messageList中，由后台的定时任务每分钟上传一次

三、链路服务
1. 链路服务用来管理所有子游戏客户端和服务端连接、心跳检测和转发消息，处理40w+连接数，connectsrv有8个实例，客户端建连通过网关clb负载均衡；服务端回包通过proxy通过sessionId解出connectId回消息到connectsrv
2. 链接服务如何能承载高并发，两方面：一是服务无状态，支持水平扩容，日常维护8个实例，最多20个实例，二是服务将接收消息解包后的并发操作通过读、写channel串行处理
3. 如何让服务无状态？
3.1 每个connectsrv初始化时从redis中占用一个唯一的destId(预留了20个),需要注册destId和节点信息到etcd
3.2 每个connectsrv都有保存着与所有子游戏线程的链接线程池，有状态在用户链接，每个服务会保存一定数量的用户链接，每建立一个sessionId与用户链接就往sessionsrv上报，并维持心跳
3.3 客户端连接通过clb负载均衡到connectsrv，每个connectsrv设置一个connectproxy，服务端链接通过proxy给客户端回包，通过sessionSrv的sessionId与connectId的关联关系，通过proxy推送到conenctsrv，再发送到对应客户端
4. 如果让服务内支持并发？
4.1 服务开放tcp端口，每个启动的tcp链接会初始化读、写channel和对应的三个goruntine
4.2 启动一个goruntine循环读conn中的数据解析成包放入读channel，读goruntine将读channel中的数据包，根据onmessagecallback函数，解析分成connectsrv自身注册的包函数、转发客户端、转发服务端；connectsrv自身的函数会往加入写channel，其他类型的包会调用服务线程池中的线程，发送包
4.3 connectsrv自身的函数执行完，根据执行逻辑如心跳检测会写入写channel，包数据会写进conn，也就是走进读channel的逻辑
4.4 每个tcp连接都有三个goroutine，实际上很消耗内存，当前业务还没达到量级影响不大，当连接数达到百万级，考虑用epoll优化读写goroutine

四、游戏配置化框架
1. 框架定义状态机每个状态及进入状态函数，定义各种状态和玩法中与客户端的消息交换，棋牌数据变更，让游戏开发可以通过选择配置项加少量代码能实现一款棋牌游戏
2. 负责的额外玩法，比如换牌、精分、连杠等，以精分为例，精牌也就是万能牌，分两种模式，翻精模式，固定精牌，随机生成的精牌所有用户共用一份精牌；随精模式，每个用户自己选择精牌且在行牌阶段可以随意切换精牌；精牌定义在小局准备阶段后；
2.1 以随精为例，游戏状态机enter到随精状态，先给用户广播选择精牌请求，客户端响应用户选择，状态机事件处理器，根据messageId，进入处理事件，检测手牌，检测是否开启随精玩法，在牌局记录用户精牌，用户胡牌检测，响应精牌更换完成的消息
2.2 后续行牌中吃碰杠胡检测都会根据用户选择的精牌判断
2.3 小局结束，结算阶段，根据精分配置，检测用户的精牌是否满足精分
3. 完整开发部署两款棋牌游戏