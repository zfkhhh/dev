流程：
1. 从配置中心获得配置文件，设置全局配置；设置destmap更新回调函数
2. 初始化redis，获得配置文件serverId，查询redis中是否存在serverId的key，id++，直到不存在，插入，将serverId设置全局参数
3. 初始化etcd，根据serverId生成node结构体，已配置文件中的serverName+serverId作为key,node节点作为value，put到etcd，并设置租约，设置keepalive，保存租约id到全局变量，后续服务结束时revole租约
4. 设置服务治理pprof，暴露端口与pprof相应接口
5. 开启文件监听dest_map.json和message_map.json；文件更新时重置全局变量并调用回调
5.1 dest_map保存约定好的目标服务器id(dest_id)与服务地址：
`
  "21": {
    "poolNums": 16,
    "srvAddr": "wsconnectproxy-srv.test.lan-zonst.com:8505",
    "srvName": "server-infra-wsconnectproxy-srv"
  },
`
5.2 message_map保存消息id与目标服务器id(dest_id)：
`
{
  "1": 1,
  "100": 101,
  "102": 101
}
`
现有的服务：
* 0~99：connectsrv 链接服务
* 100~199：其他srv
* 200~299:usersrv 用户中心服务
* 300~499:gamedispatchsrv
* 600~899:预留
* 1000以后：游戏服务

6.注册websocket路由，注册链接成功回调函数、链接关闭回调函数、消息发送回调函数；另起端口服务
6.1 websocket路由配置，注册ping接口，将get请求升级成webSocket协议；启动读写协程各一个；循环从链接读消息（设置链接超时SetReadDeadline），封装程Packet消息发到读channel

6.1.1 注册路由：连接确认、心跳请求、链接关闭、请求游戏房间列表、请求游戏节点配置
6.1.2 读协程：从读channel取到Packet消息，调用消息回调函数
6.1.3 写协程：从写channel取出Packet消息，更新链接超时时间（SetReadDeadline））消息序列化，往链接发送消息；如果发送失败，设置三次重试，重试消息；重试失败表示链接断开关闭链接

6.2 链接成功回调函数
6.2.1 metcics监控参数：tcp链接总数、当前计数加一
6.2.2 生成会话sessionId（serverId+链接地址+时间戳），将sessionId映射链接conn保存到内存map；给sessionId和conn添加定时器（心跳定时器、请求定时器）

* 心跳定时器：20s没有消息发送，定时器超时；请求定时器：链接5s内没有发起第一次连接确认，认为定时器超时；定时器超时会从map中移除sessionId，关闭链接conn，metcics监控tcp链接关闭总数+1

6.3 链接关闭回调函数
6.3.1 在websocket链接创建函数中defer调用关闭调用函数，当message发送完毕执行
6.3.2 清理sessionId与conn的映射，如果是客户端发起的ws链接，需要通知用户中心，用户socket断开：会通过服务队列池找到对应的链接，推送消息

* 服务队列池QueuePoolTable：dest_map的文件监听函数，回调reload函数，根据服务器地址建立链接；sessionId