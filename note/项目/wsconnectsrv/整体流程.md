流程：
1. 从配置中心获得配置文件，设置全局配置；设置destmap更新回调函数
2. 初始化redis，获得配置文件serverId，查询redis中是否存在serverId的key，id++，直到不存在，插入，将serverId设置全局参数
3. 初始化etcd，根据serverId生成node结构体，已配置文件中的serverName+serverId作为key,node节点作为value，put到etcd，并设置租约，设置keepalive，保存租约id到全局变量，后续服务结束时revole租约
4. 设置服务治理pprof，暴露端口与pprof相应接口
5. 开启文件监听dest_map.json和message_map.json；文件更新时重置全局变量并调用回调
5.1 dest_map保存约定好的目标服务器id(dest_id)与服务地址：
`
  "21": {
    "poolNums": 16,
    "srvAddr": "wsconnectproxy-srv.test.lan-zonst.com:8505",
    "srvName": "server-infra-wsconnectproxy-srv"
  },
`
5.2 message_map保存消息id与目标服务器id(dest_id)：
`
{
  "1": 1,
  "100": 101,
  "102": 101
}
`
现有的服务：
* 0~99：connectsrv 链接服务
* 100~199：其他srv
* 200~299:usersrv 用户中心服务
* 300~499:gamedispatchsrv
* 600~899:预留
* 1000以后：游戏服务

6.注册websocket路由，注册链接成功回调函数、链接关闭回调函数、消息发送完成回调函数；另起端口服务
6.1 websocket路由配置，注册ping接口，将get请求升级成webSocket协议；启动读写协程各一个；循环从链接读消息（设置链接超时SetReadDeadline），封装程Packet消息发到读channel

6.1.1 注册路由：连接确认、心跳请求、链接关闭、请求游戏房间列表、请求游戏节点配置
6.1.2 读协程：从读channel取到Packet消息，调用消息回调函数
6.1.3 写协程：从写channel取出Packet消息，更新链接超时时间（SetReadDeadline））消息序列化，往链接发送消息；如果发送失败，设置三次重试，重试消息；重试失败表示链接断开关闭链接

6.2 链接成功回调函数
6.2.1 metric监控参数：tcp链接总数、当前计数加一
6.2.2 生成会话sessionId（serverId+链接地址+时间戳），将sessionId映射链接conn保存到session管理器（内存map）；给sessionId和conn添加定时器（心跳定时器、请求定时器）

* 心跳定时器：20s没有消息发送，定时器超时；请求定时器：链接5s内没有发起第一次连接确认，认为定时器超时；定时器超时会从map中移除sessionId，关闭链接conn，metcics监控tcp链接关闭总数+1

6.3 链接关闭回调函数
6.3.1 在websocket链接创建函数中defer调用关闭调用函数，当message发送完毕执行
6.3.2 清理sessionId与conn的映射，如果是客户端发起的ws链接，需要请求用户中心，表示用户socket断开（会通过服务队列池找到对应的链接，推送消息）

* 服务队列池QueuePoolTable：dest_map的文件监听函数，回调reload函数，根据服务器地址建立 服务器id(dest_id)与destmap中配置的poolNum数量的链接；每次通过发送消息时，通过hash sessionId获得index，从链接池中获得一个链接发送消息

6.4 消息发送完成回调函数
6.4.1 从读channel取得packet消息，调用回调
6.4.2 先将metric监控参数：消息接收数量+1；将心跳定时器重置；
6.4.3 解析packet包中的messageId，从ws路由中拿到messageId对应的func，执行func
6.4.4 如果messageId没有注册路由，说明这个消息是给其他服务，需要将消息发送到对应服务
6.4.4.1 前面通过message_map获得了所有messageId与服务的映射，找到destId；
6.4.4.2 如果没找到，打印报错日志（实际上并没有返回消息包通知客户端）；
6.4.4.3 找到，先屏蔽发给自己的（不应该messageId存在又没有路由），在服务队列池QueuePoolTable通过destId找到链接池，根据sessionId获得index,拿到链接推送

7. 注册tcp路由，和websocket路由大致一样
7.1 消息发送完成回调函数
7.1.1 处理消息，未注册路由的messageId，转发其他服务
7.1.1.1 如果是客户端请求转发其他服务器,和ws一样
7.1.1.2 如果是服务端发来的message转给其他服务，通过目标服务器id，获得链接发送消息
7.1.1.3 如果是响应客户端消息，通过message拿到sessionId，在session管理器中获得用户链接，通过用户链接发送消息

8. 路由
8.1 客户端请求（ws和tcp存在不同）
8.1.1 ws
8.1.1.1 如果是服务端发送的消息，关闭当前链接的请求定时器，请求结束
8.1.1.2 解析请求中的token，获得userId等登录用户信息，往redis存用户id与当前链接context信息（包括服务id,sessionId等）
8.1.1.3 将请求定时器关闭，往用户中心服务发起http请求，发送登录用户信息和链接context信息
8.1.1.4 往链接写入packet（10s心跳包）

8.1.2 tcp
8.1.2.1 如果是服务端发送的消息，关闭当前链接的请求定时器，请求结束
8.1.2.2 往链接写入packet（10s心跳包）