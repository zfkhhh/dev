一、游戏服务
1. 当前子游戏运行时，以内存中的桌子对象为游戏的实体，对游戏开始的游戏、用户信息，游戏过程中的请求响应信息，小局大局结束的结算信息进行了回放日志记录
1.1 回放日志记录在缓存区，只有在小局大局结束时才会记录到redis，记录失败会记录到本地文件
1.2 游戏服务器宕机恢复问题：因为所有游戏实体都是内存对象，日志也没有及时存放，一旦游戏服务器宕机，用户游玩数据就会丢失；应该设置类似于redis的持久化方案，当缓存区数据到达一定量或者每秒写入redis
1.3 游戏数据回放问题：因为回放日志是记录到游戏的每一步，这也是回放必须的，但是数据恢复就会比较慢，可以类似于rdb，定时对游戏数据进行快照，快照桌子对象即可，恢复游戏时直接reload桌子对象就恢复了
1.4 一些组件的作用
1.4.1 redis：redis存放回放、战绩、登录日志；游戏开始时存储桌子上每个用户的数据，用户离开时删除用户数据；获取其他服务如机器人服务提供的机器人信息
1.4.2 etcd：子游戏sdk中写死的etcd配置，用于服务治理，会注册当前子游戏的本地ip和随机的端口（net.Dial("udp", "8.8.8.8:8"),conn.LocalAddr()），开放pprof和metrics接口
1.4.3 mq：子游戏作为mq的生产者，上报棋局的数据

二、链接服务connectsrv
1. 链接服务保存了部分用户链接和所有的服务内链接，当用户与connectsrv完成第一次请求，会向用户中心发送userid，sessionid，connectsrvId，gameId等信息，当用户和connectsrv完成心跳时，就会给sessionsrv发送请求注册sessionid与connectsrvId映射；用户的请求通过proxy会找到对应的connectsrv
2. 如果链接服务器宕机，就会导致用户链接全部断开，因为所有的用户的心跳检测同时也会与sessionsrv心跳检测，那么connectsrv的用户链接断开，sessionsrv也会检测到，就会删除掉sessionid与connectsrv的映射关系；接下来就是客户端重新与某个connectsrv建连，和对应的游戏进程确认游戏状态，先下发游戏规则消息和游戏数据，根据游戏进入的阶段发送对应的数据
3. 链接服务只是保存客户端与服务端的两个链接，将消息中转；所以服务宕机，重建客户端到某个conncectsrv到链接，只需要消息能够顺利到connectsrv，connectsrv会根据包中的destId中转到服务端，服务端会根据包中的deskId找到对应的桌子线程