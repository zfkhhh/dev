一、tcp四元组：发送方 IP+端口 ；接收方 IP+端口

二、三次握手

1. tcp头包括了序列号、确认序列号、一些标志位：确认同步ack, 请求同步syn等
2. 发送发先初始化一个随机序列号x,将syn置为1，发送给接收方
3. 接收方接收到syn报文，将确认序列号设置为x+1，初始化一个随机序列号y，将ack,syn置为1，发送给发送方
4. 发送方收到ack报文，将确认序号置为y+1,发送ack报文，这次报文会携带发送方数据，进入establisher状态
5. 接收方接收到ack报文，进入establisher状态，建立了连接

为什么是三次握手？
1. 防止重复的历史连接初始化；如果是两次握手，当网络阻塞，客户端多次syn，旧的syn先抵达，接收方收到syn建立连接，然后发送发送方旧的序列号，发送方判断不是该序列号，发送RST，浪费了一次连接资源
如果是三次握手，旧syn抵达，不会增加建立连接，而是继续等待发送方确认序列号


三、四次挥手

1. 发送方发送一个fin报文，进入wait1状态
2. 接收方收到fin，发送一个ack报文，进入close wait，如果还有数据要发送，继续数据发送
3. 发送方接收到fin，进入wait2，继续接收接收方的数据
4. 接收方发完了数据，发送一个fin报文
5. 发送方收到fin，发送一个ack，进入time wait状态，等待2msl，关闭连接
6. 接收方接收到ack，关闭连接

为什么要四次挥手？
主要是服务端接收到fin报文后，还需要发送数据，所以将ack和fin拆开
如果不需要发送数据，四次挥手也可以变成三次挥手

为什么time_wait等待2msl?
1. msl是指报文在网络中的最大存活时间，超过这个时间报文就会被丢弃
2. 2msl就是允许报文丢失一次，被动关闭方没有接收到最后的ack报文，会重发fin，2msl时间就能保证关闭方能接收到重试消息

为什么需要time_wait?
1. 防止历史连接到数据被相同四元组接收，因为序列号是随机的且是循环的，当序列号到达最大值会回到最小值，也就是可能新旧连接到序号会重复，time_wait能保证旧连接到数据被丢弃
2. 被动关闭的一方，能正确的关闭，能确保最后的ack能被被动关闭方接收

四、当客户端异常了，会怎么样

客户端异常，服务端检测不到，所以有keepalive机制，服务端会定时发送探测报文，如果多个探测报文都没有响应，就认为当天tcp连接已死亡
linux下探测报文时间会很长，我们会在应用层设置心跳服务

五、服务端异常了，会怎么样

服务端异常，内核会回收所有的连接，由内核发起四次挥手