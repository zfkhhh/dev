一、为什么map线程不安全
1. 多协程对map读写的时候会有数据竞态的问题，导致最后的结果和执行顺序有关，由于协程执行顺序是不确定的，导致结果也不确定，而且并发读写会panic
2. hash冲突问题，不同的键可能会hash到同一位置，map用链表解析hash冲突，在并发情况下涉及链表的修改可能会数据丢失、覆盖
3. 动态扩容问题，map在达到一定条件，会触发双倍扩容，bucket的迁移是渐进式的，当迁移bucket的时候会将旧bucket标记为删除，并发情况查询已经删除但在新bucket还没找到

二、解决方案
1. 加锁 map+sync.RWMutex，通过读写锁，让读写、写写互斥，可以同时读；而且sync.RWMutex是写者优先，可以保证写数据的性能，读数据能读到最新数据
1.1 这里需要注意，如果map较大，且写频繁，可以设计将map的锁粒度降低，map分成多份，一次只给影响到的部分map加锁
2. sync.map；sync.map本身通过空间换时间,存在只读map和写map进行读写分离，降低锁时间来提升效率
2.1 sync.map查询时先查读map，查询不到加锁查写map
2.2 增改时，会加锁写入写map并重置读map
2.3 明显sync.map适合大量读的场景，如果是大量写的场景，读map会读不到数据大量加锁，而写map会变成读map，而且写操作会更新两个map，损耗性能；实际使用中一般都是map+sync.RWMutex
