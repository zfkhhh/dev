一、垃圾回收的场景
有两种，手动调用、自动调用
1. 手动调用：runtime.gc
2. 自动调用，源码里有三个枚举
2.1 堆空间大小超过控制器设置的堆空间大小
2.2 一定事件内没有触发gc，默认2分钟
2.3 要求启动新一轮的gc，如果已启动则跳过，在runtime.gc函数中使用了这个状态

二、三色标记法
1. 所有对象初始为白色
2. 从根节点出发，遍历下一层的节点，标记为灰色，放到灰色集合中
3. 从灰色集合取出对象，获得灰色对象的下一个对象，标记为灰色放入灰色集合，黑色对象放入黑色集合
4. 重复直到灰色集合没有对象，清除掉所有的白色对象

因为用户可以在标记过程中修改对象引用，所以三色标记本事是不能并发的，需要stw；但是stw会阻塞程序，引入了内存屏障的方式减少stw

三、内存屏障
1. 要在并发过程中保证数据一致，需要满足强三色不变性、弱三色不变性
1.1 强三色不变性：黑色节点不能直接指向白色节点
1.2 弱三色不变性：黑色节点指向的白色节点，必须包含一条灰色节点到白色节点的可达路径

插入写屏障和删除写屏障发展出混合写屏障
2. 混合写屏障：
2.1 gc开始时所有可达对象标记为黑色（无需stw）
2.2 新插入、删除的对象标记为灰色，
2.3 继续三色标记的流程，灰色对象到黑色对象变动
2.4 可以保证gc过程能发现对象的引用变动