一、垃圾回收的场景
有两种，手动调用、自动调用
1. 手动调用：runtime.gc
2. 自动调用，源码里有三个枚举
2.1 堆空间大小超过控制器设置的堆空间大小
2.2 一定时间内没有触发gc，默认2分钟
2.3 要求启动新一轮的gc，如果已启动则跳过，在runtime.gc函数中使用了这个状态

二、三色标记法
1. 所有对象初始为白色
2. 从根节点出发，遍历下一层的节点，标记为灰色，放到灰色集合中
3. 从灰色集合取出对象，获得灰色对象的下一个对象，标记为灰色放入灰色集合，黑色对象放入黑色集合
4. 重复直到灰色集合没有对象，清除掉所有的白色对象

因为用户可以在标记过程中修改对象引用，所以三色标记本事是不能并发的，需要stw；但是stw会阻塞程序，引入了内存屏障的方式减少stw

三、内存屏障
1. 要在并发过程中保证数据一致，需要满足强三色不变性、弱三色不变性
1.1 强三色不变性：黑色节点不能直接指向白色节点
1.2 弱三色不变性：黑色节点指向的白色节点，必须包含一条灰色节点到白色节点的可达路径

插入写屏障和删除写屏障发展出混合写屏障
2. 混合写屏障：
2.1 gc开始时所有可达对象标记为黑色（无需stw）
2.2 新插入、删除的对象标记为灰色，
2.3 继续三色标记的流程，灰色对象到黑色对象变动
2.4 可以保证gc过程能发现对象的引用变动

四、sync.pool
1. sync.pool可以认为是对象池，用来存放和复用临时对象，减少内存分配和gc压力；当大量临时对象创建分配到了堆会影响gc，可以用sync.pool存放对象，使用时直接取而不需要创建，在对象不活跃了会自动清理；像gin就用sync.pool来存放使用gin.Context
2. sync.pool需要一个new方法，用于保存到pool中对象的创建，get方法获得对象，如果池中有对象直接取，没有对象就调用new创建，put方法放回sync.pool
3. sync.pool是线程安全的，注意的是我们提供的new方法需要并发安全，因为创建本身存在并发的
3.1 sync.pool的线程安全在于它的设计，底层有gmp模型p数量个的数组，中每个p都操作不同的数据，然后用runtime.procPin将当前协程固定在对应的p，读数据的时候完全占有p不会被抢占
4. sync.pool结构体：有一个local指针，指向poolLocal数组；localsize表示这个数组大小；new函数是用户传入的创建函数；victim数组和victemsize和local一样结构，在垃圾回收的时候会将victem清除，将local赋值给victim
5. poollocal数组是goroutine的p的数量，这样每个p都有本地空间，当并发时p只操作自己空间；poollocal结构体有一个poolLocalInternal结构，字段private缓存一个元素，只能一个g存取，优先存取private，字段share是一个双向链表
6. get方法，先pin方法会获得当前p进而获得p对应的poollocal，先从private取出，然后将private设置为nil，如果没读到了就将从share中pop，还没有就从别的poollocal的share队列尾获取，没有的话再从victim获取（victim是上轮回收的对象池）再没有就创建
7. put方法，先pin获得p及poolocal,如果private为空赋值给private，不为pushHead到share
8. gc：在init方法注册在gc发生时清理对象，它是在每个pool初始化加到全局变量allPools，gc触发时，清理allPools，放到vicitm，在下轮gc清理掉vicitem