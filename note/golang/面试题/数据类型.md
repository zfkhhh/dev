引用类型：slice, map, channel ,interface, 指针，func
值类型：其他类型

实际上golang参数传递都是值传递，但是引用类型底层结构体包含指针，值传递时复制指针地址

一、make和new
两个函数都是用于给类型分配空间
区别：
1. make只用与slice,map,channel；new用于所有类型
2. make提供参数，slice有长度，容量参数，channel有缓存大小参数；new没有参数
3. make分配空间并初始化数据结构；new分配空间并返回指向这内存空间的指针

二、slice
slice底层为一个数组地址，长度，容量；底层数组是一个连续的内存空间，所有的操作都是在数组上操作

扩容：
1. 在go1.18以前，长度小于1024，扩容到2倍；大于1024，扩容到1.25倍；如果长度小于1024且需要扩容的容量小于1024，直接扩容到原容量+扩容容量
2. 在go1.18以后，长度小于256，扩容到2倍；大于256，newcap = oldcap + (oldcap+3*256) / 4

三、map
1. map底层结构是hmap，包含了bucket指向桶数组的指针，b存放了桶数量的对数，oldbucket是一个桶列表的指针，用于保存扩容时bucket
2. bmap桶,桶最多装8个key、value，定义了key，value数组，通过hash计算key放于数组的哪个位置，并在tophash对应位置标记（注意：key,value是各自放在对应数组，好处是减少padding，节省空间）；如果key hash计算在桶的位置冲突了或者超过8个，会创建新的桶，并定义了指针overflow指向这个桶
3. 扩容过程
3.1 装载因子=元素数量/2^桶数量；如果装载因子大于6.5，表示很多bucket已经要装满了，扩容；如果overflow bucket过多，表示key比较分散
3.2 对于两种情况：情况1会扩容两倍的bucket;情况2会等量扩容，创建新bucket将旧bucket数据迁移，gc会清理溢出桶
3.3 扩容的流程：使用oldbucket指向旧的bucket，bucket存放新地址，如果翻倍扩容就创建两倍大小的bucket数组，如果是等量扩容就创建同等大小，将数据从oldbucket迁移到新bucket，删除oldbucket
3.3 渐进式扩容：一次搬迁所有key会影响性能，渐进式每次删改创建命中key,会至多迁移2个bucket，迁移过程旧bucket会标记为删除，计算迁移到新bucket的位置;在扩容期间读数据还是先读原来的bucket列表，如果旧bucket已经迁移，查新bucket的数据；扩容期间写数据，旧bucket已经冻结了，写数据都是写到新bucket

四、channel
1. channel底层结构hchan，包括一个环形队列，用一个指向数组的指针，sendx channel的发送操作处理到的位置、recvx channel的接收操作处理到的位置，构建的环形队列，sendq和recvq保存了由于缓存空间不足阻塞的goruntine，还有一个mutex锁
2. 创建channel底层调用了makechan方法，分配空间分为三种情况
2.1 缓冲区大小为0或者元素大小为0（元素为struct{}{}）的情况，只需要分配hchan的空间
2.2 channl的元素为非指针类型，分配一段连续空间，大小为缓冲区大小+hchan大小
2.3 元素为指针类型，需要分别为hchan和缓冲区分配空间
3. 发送消息，底层调用了chansend方法
3.1 channel为nil，挂起阻塞；对于无缓冲区或者有缓冲区但缓冲区已满，直接返回失败，channel已关闭返回panic
3.2 对于有缓冲区且未满，发送消息需要加锁
3.2.1 如果recvq存在等待的goruntine，将消息发送给链表头的goruntine
3.2.2 如果缓冲区未满，且没有等待的goruntine，将消息发送到sendx指向到环形队列位置
3.2.3 如果缓冲区已满，解锁发送失败
3.2.4 如果是阻塞发送，将当前goruntine封装成sudoq放到sendq链表尾部
4. 接收消息，底层调用chanrecv
4.1 如果channel为nil会挂起goruntine阻塞；加锁，如果channel已关闭并且缓冲区无数据返回数据类型的零值
4.2 如果sendq有goruntine，有两种情况，无缓冲区，缓冲区已满
4.2.1 无缓冲区，直接从发送goruntine接收消息
4.2.2 缓冲区已满，从缓冲区recvx处读消息，往缓冲区尾部写消息
4.3 如果缓冲区中有数据，正常接收然后调整recvx指针（关闭状态的channel如果缓冲区有数据也是正常的接收）
4.4 阻塞接收，将当前goruntine封装成sudog加入到recvq链表尾部
5. 关闭
5.1 关闭时，会遍历sendq和recvq,取出sudog中的goruntine加入glist，清理sudog上的信息
5.2 遍历glist，等待goruntine被调度，执行goruntine阻塞后面的逻辑
6. channel注意的，close nil和close状态的channel会panic；读 nil状态的channel会阻塞，读 close状态的channel会读到channel的数据类型的零值；写 nil状态的channel会阻塞，写close状态的channel会panic
