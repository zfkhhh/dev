引用类型：slice, map, channel ,interface, 指针，func
值类型：其他类型

实际上golang参数传递都是值传递，但是引用类型底层结构体包含指针，值传递时复制指针地址

一、make和new
两个函数都是用于给类型分配空间
区别：
1. make只用与slice,map,channel；new用于所有类型
2. make提供参数，slice有长度，容量参数，channel有缓存大小参数；new没有参数
3. make分配空间并初始化数据结构；new分配空间并返回指向这内存空间的指针

二、slice
slice底层为一个数组地址，长度，容量；底层数组是一个连续的内存空间，所有的操作都是在数组上操作

扩容：
1. 在go1.18以前，长度小于1024，扩容到2倍；大于1024，扩容到1.25倍；如果长度小于1024且需要扩容的容量小于1024，直接扩容到原容量+扩容容量
2. 在go1.18以后，长度小于256，扩容到2倍；大于256，newcap = oldcap + (oldcap+3*256) / 4

三、map
1. map底层结构是hmap，包含了bucket指向桶数组的指针，b存放了桶数量的对数，oldbucket是一个桶列表的指针，用于保存扩容时bucket
2. bmap桶,桶最多装8个key、value，定义了key，value数组，通过hash计算key放于数组的哪个位置，并在tophash对应位置标记（注意：key,value是各自放在对应数组，好处是减少padding，节省空间）；如果key hash计算在桶的位置冲突了或者超过8个，会创建新的桶，并定义了指针overflow指向这个桶
3. 扩容过程
3.1 装载因子=元素数量/2^桶数量；如果装载因子大于6.5，表示很多bucket已经要装满了，扩容；如果overflow bucket过多，表示key比较分散
3.2 对于两种情况：情况1会扩容两倍的bucket;情况2会等量扩容，创建新bucket将旧bucket数据迁移，gc会清理溢出桶
3.3 扩容的流程：使用oldbucket指向旧的bucket，bucket存放新地址，如果翻倍扩容就创建两倍大小的bucket数组，如果是等量扩容就创建同等大小，将数据从oldbucket迁移到新bucket，删除oldbucket
3.3 渐进式扩容：一次搬迁所有key会影响性能，渐进式每次删改创建命中key,会至多迁移2个bucket，在扩容期间读数据还是读原来的bucket列表，写数据会写到两个数组

四、channel
1. channel底层结构hchan包括了用缓存区指针、sendx channel的发送操作处理到的位置、recvx channel的接收操作处理到的位置，构建的环形队列，sendq和recvq保存了由于缓存空间不足阻塞的goruntine
2. channel注意的，close nil和close状态的channel会panic；读 nil状态的channel会阻塞，读 close状态的channel会读到channel的数据类型的零值；写 nil状态的channel会阻塞，写close状态的channel会panic
