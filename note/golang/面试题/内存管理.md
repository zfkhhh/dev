一、TCMalloc
1. go的内存管理是基于TCMalloc算法，它的核心思想是为每个线程分配一块缓存空间，线程申请小内存时直接从本地缓存分配空间；、
2. 这么做的优点只需要预缓存一次系统调用，后续线程分配内存都是在用户态执行；线程间操作不同的内存空间，不需要锁

二、go内存管理
1. go在程序启动时，会向操作系统申请一块虚拟内存空间，分为三部分，arena 512GB, bitmap 16GB, spans 512MB
1.1 arena也就是堆区，分配的内存都在这个区域，把内存分为数据页8kb，一些连续的页组合为mspan,mspan是内存管理的基本单元
1.2 bitmap标识arena区哪些地址保存了对象，一个byte大小对应了4个arena对象指针（4bit标识对象是否包含指针，4bit标识是否gc扫描标记），这样就算512Gb/(4*8bit)=16Gb
1.3 spans用1byte存放的mspan的指针，512Gb/8kb * 8b=512Mb
2. 内存管理单元是mspan,它是一个包含前后指针、起始地址、mspan类型、页数量等属性的双向链表
2.1 它会根据自身的size class分成多个object并且用bitmap标识未使用的object,mspan会分配小于object大小的对象；其中size class在代码中写死在了几个数组中，分别对应size class编号对应能分配的object大小，且对应了页数量。如size class=3,对应32b既能分配17b-32b大小的对象，对应能分到1页数据页
2.2 mspan实际上有两个，分别对应分配给有指针和没有指针的对象，便于gc
3. go的内存分配组件有三个：mcache,mcentral,mheap
3.1 mcache,每个调度器p都会绑定一个mcache，本地缓存可用的mspan，这样给每个goruntine分配内存时不会有资源竞争，不需要消耗锁资源
3.2 mcentral为mcache分配mspan资源，每一个mcentral对应一种mspan类型，mcentral是所有线程共有的，并发时需要锁；
3.2.1 它的底层结构有两个双向链表，empty指向没有空闲object或者被mcache使用的mspan,nonempty指向存在空闲object的mspan
3.2.2 mcache从mcentral获取mspan的过程是：加锁，从nonempty中找到一个可用的mspan,从nonempty删除，加入empty，解锁；释放过程相反
3.3 mheap是go程序的所有堆空间，底层结构有一个size class数量的central数组，bitmap指针，spans指针；当mcentral中mspan不足，需要在central数组中对应的mcentral加锁获取mspan；当mheap资源不足会向操作系统申请内存
3.3.1 mheap主要用于分配大对象，及管理未分割的mspan给mcentral分割成小对象

三、内存分配
1. go将对象分为tiny对象（小于16b并且不包含指针）；小对象（16b到32kb）；大对象（大于32kb）
2. 对象分配：对应大于32kb的大对象，直接在mheap中分配；小于16b的对象在mcache的tiny分配器分配
2.1 16b到32kb的对象，按照对应的规格，在mcache相同规格的mspan分配，如果没有向对应规格的mcentral申请从nonempty链表获取，没有向mheap中对应的mcentral获取，再没有向操作系统申请内存