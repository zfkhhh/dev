一、内存逃逸
1. 堆空间、栈空间
1.1 栈空间：内存的分配和回收是内存管理的最大的两个问题，简单高效的方法就是对一段连续空间线性分配，栈空间就是这样一段连续空间，用于存储指令过程的临时变量；栈空间是编译器自动分配和释放，存储着整个函数过程的临时数据，随着函数结束而释放
1.2 堆空间：由程序员和编译器控制，在代码编译期间通过逃逸分析把栈上的变量分配到堆空间，由堆管理器复制分配，gc时释放
2. 程序中每个函数都会有一个栈帧存放临时变量，随着函数的结束而销毁，当栈上当变量在函数结束后还想使用，就需要把变量从栈上移动到堆上；内存逃逸指的就是数据从栈空间逃逸到堆空间
3. 逃逸分析就是程序在编译阶段根据代码中的数据流，对变量分配在栈上还是堆上的静态分析的方法
4. 逃逸分析遵循两个不变性：指向栈上的对象的指针不能存在与堆中；指向栈上的对象的指针不能在栈对象回收后存活
5. 逃逸分析在编译阶段解析，通过go build -gcflags '-m -m -l'可以得到逃逸分析的结构
6. 逃逸分析的场景
6.1 指针逃逸：函数中创建了对象，返回了对象的指针
6.2 interface动态类型逃逸：如果函数入参是interface{}类型，编译阶段很难确定参数的具体类型，会发生逃逸
6.3 闭包逃逸：匿名函数本身也是指针，如果返回函数中，存在局部变量的引用，局部变量会存活到匿名函数销毁，局部变量发生逃逸
6.4 变量大小不确定或栈空间不足：操作系统对线程的栈的空间大小有限制，64位系统上通常是8M，go初始化栈空间是2kb，函数运行中超过大小会发生扩容，但也不会超过线程的栈空间限制，当局部变量大小超过栈空间大小，会逃逸到堆；如果创建切片，大小是传入参数，不是明确的数字，为了内存安全，也会逃逸到堆

二、内存泄漏
1. 内存泄漏指程序已不再使用的内存没有被及时的释放，导致这部分内存无法使用
2. 常见的场景
2.1 goruntine泄漏
2.1.1 io阻塞未设置超时时间
2.1.2 互斥锁未释放
2.1.3 waitgroup使用不当，add与done与wait数量不匹配
2.2 select阻塞：select会阻塞读写
2.3 timer使用不当
2.3.1 timer.after(duration)会产生一个channel，等待时间如果较大会存在内存泄漏
2.3.2 time.NewTicker未关闭
2.4 slice使用
2.4.1 获取长slice的部分导致长slice一直没有释放
2.4.2 用slice新建slice导致旧slice不能被释放
3. pprof：以profile.proto读取分析样本，生成可视化的报告
3.1 采样方式
3.1.1 runtime/pprof：采集程序的指定区块的数据进行分析
3.1.2 http/pprof：基于http服务，采集运行时数据
3.1.3 go test：运行测试用例，已指定标识采集数据
3.2 采集的数据
3.2.1 cpu分析：采集程序cpu的使用情况
3.2.2 内存分析：堆分配时记录堆栈跟踪
3.2.3 阻塞分析：记录goruntine阻塞等待同步的位置
3.2.4 mutex互斥锁分析：互斥锁的竞争情况
3.2.5 goruntine分析：对goruntine进行堆栈追踪