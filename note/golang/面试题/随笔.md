1. 变量交换：num[a],num[b] = num[b],num[a];从汇编代码来看，用了一个栈空间的临时变量存放第一个变量num[a]
2. golang的异常处理机制：golang没有结构化异常，使用panic抛出异常，然后recover捕获异常；panic会中止要执行的代码退出goruntinue；recover会获得goruntine中的panic错误信息并恢复程序正常运行
2.1 recover要接住panic需要满足：
2.1.1 recover需要和panic在同一个goruntine；因为panic只会触发当前goruntine的defer
2.1.2 recover需要放在defer中执行
2.2 panic和recover会转换成runtime.gopanic和runtime.gorecover；gopanic触发时会将goruntine链表中的_defer取出并执行，当碰到gorecover会将recovered标记成true，找到后续的deferproc执行；如果没有遇到gorecover执行完_defer会调用fatalpanic中止程序
2.3 不能捕捉的异常：
2.3.1 内存溢出：oom会throw exit导致程序退出
2.3.2 map并发读写：同样throw exit
2.3.3 栈内存耗尽：栈内存初始化是2kb，虽然会扩容，但是有最大值，linux64位是1Gb
2.3.4 将nil函数交给goruntine使用
2.3.5 线程永久阻塞，检测出没有可运行的goruntine(all goroutines are asleep)会将程序crash掉