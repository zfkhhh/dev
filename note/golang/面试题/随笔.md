1. 变量交换：num[a],num[b] = num[b],num[a];从汇编代码来看，用了一个栈空间的临时变量存放第一个变量num[a]
2. golang的异常处理机制：golang没有结构化异常，使用panic抛出异常，然后recover捕获异常；panic会中止要执行的代码退出goruntinue；recover会获得goruntine中的panic错误信息并恢复程序正常运行
2.1 recover要接住panic需要满足：
2.1.1 recover需要和panic在同一个goruntine；因为panic只会触发当前goruntine的defer
2.1.2 recover需要放在defer中执行
2.1.3 可以嵌套panic,但recover捕捉到第一个panic就会进入recover的逻辑
2.2 panic和recover会转换成runtime.gopanic和runtime.gorecover；gopanic触发时会将goruntine链表中的_defer取出并执行，当碰到gorecover会将recovered标记成true，找到后续的deferproc执行；如果没有遇到gorecover执行完_defer会调用fatalpanic中止程序
2.3 不能捕捉的异常：
2.3.1 内存溢出：oom会throw exit导致程序退出
2.3.2 map并发读写：同样throw exit
2.3.3 栈内存耗尽：栈内存初始化是2kb，虽然会扩容，但是有最大值，linux64位是1Gb
2.3.4 将nil函数交给goruntine使用
2.3.5 线程永久阻塞，检测出没有可运行的goruntine(all goroutines are asleep)会将程序crash掉
3. slice append的问题
3.1 函数中append新数据，原函数感知不到；因为slice只能感知到len范围内的数据；而函数的参数传递是值引用，len的改变不会影响到原切片
`
func main() {
	var s []int
	for i := 0; i < 3; i++ {
		s = append(s, i)
	}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(s []int) {
	s = append(s, 2048)
	s[0] = 1024
}

// [1024 1 2]
`
3.2 函数中append多个数据，修改数据原函数感知不到；因为切片扩容了，底层数组指向了另一个数组，修改的是另一个数组的数据
`
func main() {
	var s []int
	for i := 0; i < 3; i++ {
		s = append(s, i)
	}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(s []int) {
	s = append(s, 2048)
	s = append(s, 2048)
	s[0] = 1024
}

// [0 1 2]
`
3.3 copy复制是深拷贝，会复制到另一个内存地址
`
func main() {
	s := []int{1, 2}
	s2 := make([]int, 4, 8)
	copy(s2, s)
	fmt.Printf("len:%d, cap:%d, s:%v\n", len(s), cap(s), s)
	s2[0] = 3
	fmt.Printf("len:%d, cap:%d, s:%v\n", len(s2), cap(s2), s2)
}

// len:2, cap:2, s:[1 2]
// len:4, cap:8, s:[3 2 0 0]
`
4. 闭包问题：闭包是指函数返回值是另一个函数，被返回的函数可以使用父函数的变量，当被返回的函数被外部执行，就形成了闭包
4.1 普通闭包：临时变量逃逸到了堆
`
func main() {
	f := foo()
	fmt.Println(f())
	fmt.Println(f())
}

func foo() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

// 1
// 2
`
4.2 闭包与defer结合；后一个函数中的defer定义时就将a=5赋值给了defer，在执行defer函数时执行时用的a是在定义时对a的拷贝并非当前环境变量中的a值
`
func main() {
	a := 5
	defer func() {
		fmt.Println("a =", a)
	}()
	a += 100
}
// 105

func main() {
	a := 5
	defer func(a int) {
		fmt.Println("a =", a)
	}(a)
	a += 100
}

// 5
`
4.3 闭包与命名返回值，bbb中return的闭包函数实际并不会立即赋值，而是在使用的时候赋值，return的函数最后又赋值了done返回值，所以最后的done是return本身，所以会递归调用，最终栈溢出
`
func main() {
	done, _ := bbb()
	done()
}

func aaa() (done func(), err error) {
	return func() {
		print("aaa: done")
	}, nil
}

func bbb() (done func(), _ error) {
	done, err := aaa()
	return func() {
		print("bbb: surprise!")
		done()
	}, err
}
`
bbb()可以看作是：
`
func bbb() (done func(), err error) {
	done, err = aaa()
	done = func() {
		print("bbb: surprise!")
		done()
	}
	return
}
`
让它不递归的方法就是不用命名返回值
`
func bbb() (func(), error) {
	done, err := aaa()
	return func() {
		print("bbb: surprise!")
		done()
	}, err
}
// bbb: surprise!aaa: done% 
`
4.4 闭包函数传参:a,b两个闭包两个临时变量t是独立的，所以a("go")影响不了b("All")
`
func app() func(string) string {
	t := "Hi"
	c := func(b string) string {
		t = t + " " + b
		return t
	}
	return c
}

func main() {
	a := app()
	b := app()
	a("go")
	fmt.Println(b("All"))
}
// Hi All
`
如果用同一个闭包函数，就会影响：
`
func main() {
	a := app()
	a("go")
	fmt.Println(a("All"))
}
// Hi go All
`

5. 怎么实现一个lru算法
5.1 为了保持顺序，使用双向链表，并且保存头尾节点指针，每次往队尾插入，内存淘汰时直接淘汰头节点
5.2 为了保证读效率，用map保存每个节点指针，key为节点key
`
type LRUCache struct {
	size       int
	capacity   int
	cache      map[int]*DLinkedNode
	head, tail *DLinkedNode
}

type DLinkedNode struct {
	key, value int
	prev, next *DLinkedNode
}
`

6. defer和return
6.1 执行顺序：先return，将结果写到返回值；再执行defer，defer按先进后出的顺序执行；再函数携带返回值退出
6.2 这里主要的问题是命名返回值被defer中修改，会生效
`
func test() (i int) { //返回值命名i
    defer func() {
        i++
        fmt.Println("defer1:", i)
    }()
    defer func() {
        i++
        fmt.Println("defer2:", i)
    }()
    return i
}
// defer2:1
// defer1:2
// 返回2
`

7. 哪些数据类型是并发安全的
7.1 数据类型可以分为
7.1.1 基本数据类型：byte,bool,string,整形，浮点，字符rune，复数
7.1.2 复合数据类型：指针，数组，切片，map, channel，interface，struct，函数
7.2 基本类型 byte,bool,整形，浮点,字符都是并发安全的，不会超过64位，由一条机器指令完成
7.3 复数分为了实部和虚部，两者分开赋值，不是并发安全的
7.4 string底层结果是一个指向字符数组的指针和长度len，字符串的修改得转成切片在修改某个字符，字符串的赋值是将指针指向新的字符数组，不是并发安全
7.5 复合数据类型：指针、函数是并发安全的；指针和函数保存的是内存地址，一条机器指令就能完成
7.6 数组、切片、map、channel、interface、struct底层都是结构体，并发不安全

8. sync.once实现
8.1 sync.once是单例模式，在once.Done的函数只会执行一次
8.2 once的结构体一个uint32的done信号量，一个mutex锁
8.3 执行逻辑：automic.LoadUint32检测done信号量是否为0，为0就是没执行，调用doSlow执行;doSlow执行先占锁，占锁成功defer automic.StoreUint32修改信号量done,调用传进来的函数

9. 如何判断结构体实现了接口的方法
9.1 编译时判断：将nil转化成结构体指针，赋值给接口，看编译时是否会报错
`
_ Dark = (*bird)(nil)
`
9.2 运行时通过断言判断
`
_, ok := Studenttest.(People);
`

10. 哪些数据类型不能作为map的key
10.1 不能比较的类型不能作为map的key, slice,map,function，包含这三种类型的array，struct
10.2 为什么这几类类型不能比较？因为这几个类型的值是不固定的，在内存中可以改变，如slice指向底层array的指针，不同slice可能指向的array相同，slice要比较不仅要比较底层数组指针相同，还有比较使用长度容量

11. string是线程安全的吗？
11.1 不是，string的值不会变，但是string变量可以赋值，string结构体包含字符指针和长度，赋值过程需要给两个字段赋值，非原子的，在并发场景会出现字符指针和长度不对的情况

