1. 变量交换：num[a],num[b] = num[b],num[a];从汇编代码来看，用了一个栈空间的临时变量存放第一个变量num[a]
2. golang的异常处理机制：golang没有结构化异常，使用panic抛出异常，然后recover捕获异常；panic会中止要执行的代码退出goruntinue；recover会获得goruntine中的panic错误信息并恢复程序正常运行
2.1 recover要接住panic需要满足：
2.1.1 recover需要和panic在同一个goruntine；因为panic只会触发当前goruntine的defer
2.1.2 recover需要放在defer中执行
2.1.3 可以嵌套panic,但recover捕捉到第一个panic就会进入recover的逻辑
2.2 panic和recover会转换成runtime.gopanic和runtime.gorecover；gopanic触发时会将goruntine链表中的_defer取出并执行，当碰到gorecover会将recovered标记成true，找到后续的deferproc执行；如果没有遇到gorecover执行完_defer会调用fatalpanic中止程序
2.3 不能捕捉的异常：
2.3.1 内存溢出：oom会throw exit导致程序退出
2.3.2 map并发读写：同样throw exit
2.3.3 栈内存耗尽：栈内存初始化是2kb，虽然会扩容，但是有最大值，linux64位是1Gb
2.3.4 将nil函数交给goruntine使用
2.3.5 线程永久阻塞，检测出没有可运行的goruntine(all goroutines are asleep)会将程序crash掉
3. slice append的问题
3.1 函数中append新数据，原函数感知不到；因为slice只能感知到len范围内的数据；而函数的参数传递是值引用，len的改变不会影响到原切片
`
func main() {
	var s []int
	for i := 0; i < 3; i++ {
		s = append(s, i)
	}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(s []int) {
	s = append(s, 2048)
	s[0] = 1024
}

// [1024 1 2]
`
3.2 函数中append多个数据，修改数据原函数感知不到；因为切片扩容了，底层数组指向了另一个数组，修改的是另一个数组的数据
`
func main() {
	var s []int
	for i := 0; i < 3; i++ {
		s = append(s, i)
	}
	modifySlice(s)
	fmt.Println(s)
}

func modifySlice(s []int) {
	s = append(s, 2048)
	s = append(s, 2048)
	s[0] = 1024
}

// [0 1 2]
`
3.3 copy复制是深拷贝，会复制到另一个内存地址
`
func main() {
	s := []int{1, 2}
	s2 := make([]int, 4, 8)
	copy(s2, s)
	fmt.Printf("len:%d, cap:%d, s:%v\n", len(s), cap(s), s)
	s2[0] = 3
	fmt.Printf("len:%d, cap:%d, s:%v\n", len(s2), cap(s2), s2)
}

// len:2, cap:2, s:[1 2]
// len:4, cap:8, s:[3 2 0 0]
`
4. 闭包问题：闭包是指函数返回值是另一个函数，被返回的函数可以使用父函数的变量，当被返回的函数被外部执行，就形成了闭包
4.1 普通闭包：临时变量逃逸到了堆
`
func main() {
	f := foo()
	fmt.Println(f())
	fmt.Println(f())
}

func foo() func() int {
	i := 0
	return func() int {
		i++
		return i
	}
}

// 1
// 2
`
4.2 闭包与defer结合；后一个函数中的defer定义时就将a=5赋值给了defer，在执行defer函数时执行时用的a是在定义时对a的拷贝并非当前环境变量中的a值
`
func main() {
	a := 5
	defer func() {
		fmt.Println("a =", a)
	}()
	a += 100
}
// 105

func main() {
	a := 5
	defer func(a int) {
		fmt.Println("a =", a)
	}(a)
	a += 100
}

// 5
`
4.3 闭包与命名返回值，bbb中return的闭包函数实际并不会立即赋值，而是在使用的时候赋值，return的函数最后又赋值了done返回值，所以最后的done是return本身，所以会递归调用，最终栈溢出
`
func main() {
	done, _ := bbb()
	done()
}

func aaa() (done func(), err error) {
	return func() {
		print("aaa: done")
	}, nil
}

func bbb() (done func(), _ error) {
	done, err := aaa()
	return func() {
		print("bbb: surprise!")
		done()
	}, err
}
`
bbb()可以看作是：
`
func bbb() (done func(), err error) {
	done, err = aaa()
	done = func() {
		print("bbb: surprise!")
		done()
	}
	return
}
`
让它不递归的方法就是不用命名返回值
`
func bbb() (func(), error) {
	done, err := aaa()
	return func() {
		print("bbb: surprise!")
		done()
	}, err
}
// bbb: surprise!aaa: done% 
`
4.4 闭包函数传参:a,b两个闭包两个临时变量t是独立的，所以a("go")影响不了b("All")
`
func app() func(string) string {
	t := "Hi"
	c := func(b string) string {
		t = t + " " + b
		return t
	}
	return c
}

func main() {
	a := app()
	b := app()
	a("go")
	fmt.Println(b("All"))
}
// Hi All
`
如果用同一个闭包函数，就会影响：
`
func main() {
	a := app()
	a("go")
	fmt.Println(a("All"))
}
// Hi go All
`

5. 怎么实现一个lru算法
5.1 为了保持顺序，使用双向链表，并且保存头尾节点指针，每次往队尾插入，内存淘汰时直接淘汰头节点
5.2 为了保证读效率，用map保存每个节点指针，key为节点key
`
type LRUCache struct {
	size       int
	capacity   int
	cache      map[int]*DLinkedNode
	head, tail *DLinkedNode
}

type DLinkedNode struct {
	key, value int
	prev, next *DLinkedNode
}
`

6. defer和return
6.1 执行顺序：先return，将结果写到返回值；再执行defer，defer按先进后出的顺序执行；再函数携带返回值退出
6.2 这里主要的问题是命名返回值被defer中修改，会生效
`
func test() (i int) { //返回值命名i
    defer func() {
        i++
        fmt.Println("defer1:", i)
    }()
    defer func() {
        i++
        fmt.Println("defer2:", i)
    }()
    return i
}
// defer2:1
// defer1:2
// 返回2
`