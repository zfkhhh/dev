一、锁的模式
1. 锁可以分为正常模式、饥饿模式
2. 正常模式：请求锁的goroutine会按先进先出的顺序排队，依次被唤醒，唤醒的goroutine需要和请求的goroutine竞争获得锁，但实际上唤醒的goroutine竞争大概率会失败，因为请求的goroutine在cpu上运行并数量较多，所以当goroutine超过1ms没有竞争到锁，会把锁设置为饥饿模式
3. 饥饿模式：锁会直接交给等待队列最前面的goroutine，新的goroutine不会参与竞争，不自旋，直接进入队尾等待；如果获得锁的goroutine满足条件：是队列的最后一个goroutine或者等待时间小于1ms，会变成正常模式
4. 正常模式有更好的性能，一个goroutine可以多次请求占有锁；饥饿模式是为了防止尾部延迟问题

二、sync.mutex
1. sync.mutex结构体只有两个字段，int32类型的state表示锁的状态，uint32类型的sema用来控制锁状态的信号量，唤醒goroutine；state的低三位表示锁状态：值为0表示没有占有锁，1对应锁已被占有，2表示锁从正常状态唤醒，4表示锁进入饥饿状态
2. 加锁流程：
2.1 先用乐观锁atomic.CompareAndSwap尝试修改state为1，如果旧值为0就修改成功，也就是加锁
2.2 修改失败，调lockslow方法尝试获得锁
2.3 首先是判断当前goroutine是否能够自旋，因为自旋会持续占有cpu，需要满足一下条件
2.3.1 当前mutex是正常模式
2.3.2 运行在多核cpu上，自旋次数小于4，存在运行的p并且本地队列是空的
2.4 通过自旋等待互斥锁的释放
2.5 计算互斥锁的最新状态
2.6 修改互斥锁的状态并获取到锁
3. 解锁流程
3.1 先尝试快速解锁，atomic.Add修改state为-1,如果返回0就成功解锁
3.2 失败就慢速解锁 unlockslow
3.3 首先判断锁是不是已被释放，unlock已释放的锁会panic
3.4 判断锁模式
3.4.1 饥饿模式，将锁交给下一个正在尝试获得锁的等待者，等待者会把锁设置为lock状态
3.4.2 正常模式，如果没有等待者或者已经有goroutine获得了锁，直接返回，其他情况会唤醒等待者并把锁交给等待者


三、sync.RWMutex
1. rwmutex是读写锁，写锁加锁解锁方法是lock,unlock；读锁加锁、解锁方法是rlock,runlock；读可以并行读，写只能串行写，锁只能由多个读协程或者一个写协程占有
2. rwmutex是写优先，但writer申请锁的时候，除了正在占有锁的读协程，其他读协程会阻塞，rwmutex机制：可以看作rwmutex有两个队列，队列a存放所有的reader和一个获得准入权的writer，队列b存放所有等待的writer；读写切换是通过信号量，写写间互斥是通过互斥锁
3. RWMutex读写锁结构体包含：mutex互斥锁，readsem用于读等待，写完后唤醒读协程，writesem用于写等待，读完后唤醒写协程，readcount保存读协程总数，也通过负数表示是否有写协程正在等待，readwait保存队列a中writer前的reader数量，还有一个常量表示读协程最大值
4. rlock：atomic.add给readcount+1，如果readcount是负数，说明有writer在前面等待，阻塞等待读信号量
5. runlock：atomic.add给readcount-1,如果readcount是负数，说明有writer在等待，需要判断当前读协程是否是最后一个读协程
5.1 将atomic.add将readwait-1，如果正好等于0，说明是最后一个读协程，释放写信号writesem，唤醒写协程；注意只有存在writer也就是writer执行lock时才会将readwait设置成readcount数量
6. lock：写协程加锁，先给互斥锁加锁，如果有其他writer已经进入了队列a也就是已加锁，需要等待锁释放；加锁成功，先atomic.add将readcount减去最大值常量成为负数，再加上最大值拿到原有的readcount，如果readcount不等于0说明前面已有读协程，atomic.add将readwait加上readcount，等待写信号
7. unlock：写协程解锁，atomic.add将readcount加上最大值也就是恢复正数，然后将writer后的readcount数量的读协程都释放读信号readersem，释放互斥锁
8. 读写锁的特点：不可复制、不可重入、加解锁必须成对存在

四、碰到的问题
1. rwMutex死锁：一个goruntine中会产生两个读锁，通过defer解锁也就是goruntine退出才会解锁，另一个goruntine在两个读锁间加上写锁，写锁需要等待前面的读锁释放，而第二个读锁加锁需要写锁释放；造成死锁
`
func main() {
	var l sync.RWMutex
	var wg sync.WaitGroup
	wg.Add(2)

	c := make(chan int)
	go func() {
		defer wg.Done()

		l.RLock()
		defer l.RUnlock()
		fmt.Println("acquire RLock first")

		c <- 1
		runtime.Gosched()

		fmt.Println("wait readLock")
		l.RLock()
		defer l.RUnlock()
		fmt.Println("acquire RLock second")
	}()

	go func() {
		defer wg.Done()

		<-c

		fmt.Println("wait writeLock")
		l.Lock()
		defer l.Unlock()
		fmt.Println("acquire Lock")
	}()

	wg.Wait()
	fmt.Println("test finish")
}
`