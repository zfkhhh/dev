一、锁的模式
1. 锁可以分为正常模式、饥饿模式
2. 正常模式：请求锁的goroutine会按先进先出的顺序排队，依次被唤醒，唤醒的goroutine需要和请求的goroutine竞争获得锁，但实际上唤醒的goroutine竞争大概率会失败，因为请求的goroutine在cpu上运行并数量较多，所以当goroutine超过1ms没有竞争到锁，会把锁设置为饥饿模式
3. 饥饿模式：锁会直接交给等待队列最前面的goroutine，新的goroutine不会参与竞争，不自旋，直接进入队尾等待；如果获得锁的goroutine满足条件：是队列的最后一个goroutine或者等待时间小于1ms，会变成正常模式
4. 正常模式有更好的性能，一个goroutine可以多次请求占有锁；饥饿模式是为了防止尾部延迟问题

二、sync.mutex
1. sync.mutex结构体只有两个字段，int32类型的state表示锁的状态，uint32类型的sema用来控制锁状态的信号量，唤醒goroutine；state的低三位表示锁状态：值为0表示没有占有锁，1对应锁已被占有，2表示锁从正常状态唤醒，4表示锁进入饥饿状态
2. 加锁流程：
2.1 先用乐观锁atomic.CompareAndSwap尝试修改state为1，如果旧值为0就修改成功，也就是加锁
2.2 修改失败，调lockslow方法尝试获得锁
2.3 首先是判断当前goroutine是否能够自旋，因为自旋会持续占有cpu，需要满足一下条件
2.3.1 当前mutex是正常模式
2.3.2 运行在多核cpu上，自旋次数小于4，存在运行的p并且本地队列是空的
2.4 通过自旋等待互斥锁的释放
2.5 计算互斥锁的最新状态
2.6 修改互斥锁的状态并获取到锁
3. 解锁流程
3.1 先尝试快速解锁，atomic.Add修改state为-1,如果返回0就成功解锁
3.2 失败就慢速解锁 unlockslow
3.3 首先判断锁是不是已被释放，unlock已释放的锁会panic
3.4 判断锁模式
3.4.1 饥饿模式，将锁交给下一个正在尝试获得锁的等待者，等待者会把锁设置为lock状态
3.4.2 正常模式，如果没有等待者或者已经有goroutine获得了锁，直接返回，其他情况会唤醒等待者并把锁交给等待者


三、sync.RWMutex
1. RWMutex读写锁结构体包含：mutex互斥锁，readsem用于读等待写，writesem用于写等待读，readcount保存正在读的goruntine数量，readwait保存写阻塞时读操作等待读数量；写锁加锁解锁方法是lock,unlock；读锁加锁、解锁方法是rlock,runlock
