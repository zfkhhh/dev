一、内存逃逸
1. 堆空间、栈空间
1.1 栈空间：内存的分配和回收是内存管理的最大的两个问题，简单高效的方法就是对一段连续空间线性分配，栈空间就是这样一段连续空间，用于存储指令过程的临时变量；栈空间是编译器自动分配和释放，存储着整个函数过程的临时数据，随着函数结束而释放
1.2 堆空间：由程序员和编译器控制，在代码编译期间通过逃逸分析把栈上的变量分配到堆空间，由堆管理器复制分配，gc时释放
2. 内存逃逸一般指数据从栈空间逃逸到堆空间，当函数运行结束会释放栈空间，如果逃逸到堆空间就会等到gc才会销毁
3. 逃逸分析遵循两个不变性：指向栈上的对象的指针不能存在与堆中；指向栈上的对象的指针不能在栈对象回收后存活
4. 逃逸分析是静态分析的一种，会解析go源文件，构建抽象语法树，根据代码中的数据流，分析哪些变量在栈上、堆上分配
5. 逃逸分析在编译阶段解析，通过go build -gcflags '-m -m -l'可以得到逃逸分析的结构
6. 逃逸分析的场景
6.1 指针逃逸：函数中创建了对象，返回了对象的指针
6.2 interface动态类型逃逸：如果函数入参是interface{}类型，编译阶段很难确定参数的具体类型，会发生逃逸
6.3 闭包逃逸：匿名函数本身也是指针，如果返回函数中，存在局部变量的引用，局部变量会存活到匿名函数销毁，局部变量发生逃逸
6.4 变量大小不确定或栈空间不足：操作系统对线程的栈的空间大小有限制，64位系统上通常是8M，go初始化栈空间是2kb，函数运行中超过大小会发生扩容，但也不会超过线程的栈空间限制，当局部变量大小超过栈空间大小，会逃逸到堆；如果创建切片，大小是传入参数，为了内存安全，也会逃逸到堆